diff --git a/dist/browser/index.js b/dist/browser/index.js
index f2bdb93519c9cd1e2403214ea94025817b04bbd5..40e0fb72f9435df1b9e7b1dcdb97bb497c0f920e 100644
--- a/dist/browser/index.js
+++ b/dist/browser/index.js
@@ -1,2 +1,2 @@
-import{ciphertext as e,privateKey as t,signature as s,publicKey as n,fetcher as r,keystore as i,message as o,content as a,authn as c,messageApi as d,invitation as h,contact as y,privatePreferences as u}from"@xmtp/proto";import l from"long";import*as p from"@noble/secp256k1";import{bytesToHex as w,keccak256 as f,getAddress as m,hexToSignature as g,hexToBytes as v,hashMessage as b,verifyMessage as E}from"viem";import{ContentTypeText as K,TextCodec as k}from"@xmtp/content-type-text";import{ContentTypeId as A}from"@xmtp/content-type-primitives";import{Mutex as S}from"async-mutex";import T from"elliptic";import C,{user_preferences_encrypt as P,user_preferences_decrypt as I,generate_private_preferences_topic as B}from"@xmtp/user-preferences-bindings-wasm/web";import{createConsentMessage as R}from"@xmtp/consent-proof-signature";class N{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return e.Ciphertext.encode(this).finish()}static fromBytes(t){return new N(e.Ciphertext.decode(t))}}const D=window.crypto,x=(new Uint8Array).buffer,M=(new Uint8Array).buffer;async function _(e){return new Uint8Array(await D.subtle.digest("SHA-256",e))}async function V(e,t,s){const n=D.getRandomValues(new Uint8Array(32)),r=D.getRandomValues(new Uint8Array(12)),i=await q(t,n),o=await D.subtle.encrypt(L(r,s),i,e);return new N({aes256GcmHkdfSha256:{payload:new Uint8Array(o),hkdfSalt:n,gcmNonce:r}})}async function U(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const n=await q(t,e.aes256GcmHkdfSha256.hkdfSalt),r=await D.subtle.decrypt(L(e.aes256GcmHkdfSha256.gcmNonce,s),n,e.aes256GcmHkdfSha256.payload);return new Uint8Array(r)}function L(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function q(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:x},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function O(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:M,info:t},s,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}async function G(e,t,s){const n=await O(e,t),r=await D.subtle.sign("HMAC",n,s);return new Uint8Array(r)}async function H(e,t,s){return await D.subtle.verify("HMAC",e,t,s)}async function F(e){const t=await D.subtle.exportKey("raw",e);return new Uint8Array(t)}async function $(e){return D.subtle.importKey("raw",e,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}const j=p.utils.bytesToHex;function X(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function J(e){const t=g(e),s=v(t.r),n=v(t.s);let r=Number(t.v);0!==r&&1!==r||(r+=27);const i=1-r%2,o=new Uint8Array(64);return o.set(s),o.set(n,s.length),{bytes:o,recovery:i}}function z(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class Y{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new oe(e.publicKey)}static async generate(e){const t={bytes:p.utils.randomPrivateKey()},s=l.fromNumber((new Date).getTime()).mul(1e6),n=new ie({secp256k1Uncompressed:{bytes:p.getPublicKey(t.bytes)},createdNs:s}),r=await e.signKey(n);return new Y({secp256k1:t,createdNs:s,publicKey:r})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await _(t),n=await this.sign(s);return new oe({keyBytes:t,signature:n})}static async signerKey(e,t){return ee(await _(e.bytesToSign()),t)}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return X(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return t.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new Y(t.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new Y({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:oe.fromLegacyKey(e.publicKey,t)})}}class W{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new ae(e.publicKey)}static generate(){const e={bytes:p.utils.randomPrivateKey()},t=l.fromNumber((new Date).getTime());return new W({secp256k1:e,timestamp:t,publicKey:new ae({secp256k1Uncompressed:{bytes:p.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await _(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return t.PrivateKey.encode(this).finish()}static fromBytes(e){return new W(t.PrivateKey.decode(e))}}function Q(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function Z(e,t){return e.recovery===t.recovery&&X(e.bytes,t.bytes)}function ee(e,t){const s=p.recoverPublicKey(e,t.bytes,t.recovery);return s?new ie({secp256k1Uncompressed:{bytes:s},createdNs:l.fromNumber(0)}):void 0}class te{constructor(e){if(e.ecdsaCompact)Q(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");Q(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?Y.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?ne.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=p.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=p.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new ae({secp256k1Uncompressed:{bytes:t},timestamp:l.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Z(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&Z(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return s.Signature.encode(this).finish()}static fromBytes(e){return new te(s.Signature.decode(e))}}var se;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(se||(se={}));class ne{constructor(e){this.wallet=e}static identitySigRequestText(e){return`XMTP : Create Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}static signerKey(e,t){return ee(v(b(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(ne.identitySigRequestText(t)),{bytes:n,recovery:r}=J(s),i=new te({walletEcdsaCompact:{bytes:n,recovery:r}});return new oe({keyBytes:t,signature:i})}}const re=new l(10**9).mul(10**9);class ie{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(re)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&p.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await _(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return X(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(e){const t=w(e.slice(1)),s=f(t),n=s.substring(s.length-40);return m(`0x${n}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return n.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new ie(n.UnsignedPublicKey.decode(e))}}class oe extends ie{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(n.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new te(e.signature)}get unsignedKey(){return new ie({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return n.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new oe(n.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new te({ecdsaCompact:e.walletEcdsaCompact})),new ae({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new te({walletEcdsaCompact:s.ecdsaCompact})),new oe({keyBytes:e.bytesToSign(),signature:s})}}class ae extends ie{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new te({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new te(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return n.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(ne.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:n}=J(t);this.signature=new te({ecdsaCompact:{bytes:s,recovery:n}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=v(b(ne.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return n.PublicKey.encode(this).finish()}static fromBytes(e){return new ae(n.PublicKey.decode(e))}}class ce{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new oe(e.identityKey),this.preKey=new oe(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return n.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new de({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=n.SignedPublicKeyBundle.decode(e);return new ce(t)}static fromLegacyBundle(e){return new ce({identityKey:oe.fromLegacyKey(e.identityKey,!0),preKey:oe.fromLegacyKey(e.preKey)})}}class de{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new ae(e.identityKey),this.preKey=new ae(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return n.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=n.PublicKeyBundle.decode(e);return new de(t)}}class he{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return j(await _(this.messageEnvelope.message))}async send(){return this.onSend()}}class ye{constructor(e,t,s,n,r){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,n),this.onConnectionLost=r}newMessageCallback(e,t){return async s=>{if(s.message)try{const n=await e(s);if(!n)return;if(t){const e=t(n);e&&this.resubscribeToTopics(e)}const r=this.resolvers.pop();r?r({value:n}):this.messages.unshift(n)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,n,r){const i=new ye(e,t,s,n,r);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}const{b64Decode:ue,b64Encode:le}=r;function pe(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function we(e){return l.fromNumber(e.valueOf()).multiply(1e6)}function fe(e){return new Date(e.divide(1e6).toNumber())}const me=e=>e&&we(e).toString(),ge=e=>{if(e)return fe(l.fromString(e))};class ve extends Error{constructor(e,t){super(t),this.code=e}}const be=e=>{if(e.error)throw new ve(e.error.code,e.error.message);if(!e.result)throw new ve(i.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},Ee=(e,t)=>({requests:e.map((e=>{const s=new de({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),n=t.equals(s);return{payload:e.ciphertext,peerKeys:n?new de({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:n}}))}),Ke=e=>`/xmtp/0/${e}/proto`,ke=(e,t)=>{const s=[m(e),m(t)];return s.sort(),Ke(`dm-${s.join("-")}`)},Ae=e=>Ke(`m-${e}`),Se=e=>Ke(`contact-${m(e)}`),Te=e=>Ke(`intro-${m(e)}`),Ce=e=>Ke(`invite-${m(e)}`),Pe=e=>Ke(`privatestore-${e}`),Ie=e=>Ke(`userpreferences-${e}`),Be=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const n=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(n)}return!1};class Re{constructor(e,t,s){this.conversationVersion="v1",this.context=void 0,this.peerAddress=m(t),this.client=e,this.createdAt=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return ke(this.peerAddress,this.client.address)}get ephemeralTopic(){return ke(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){const t=ke(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof de||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Te(this.peerAddress),Te(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const{payload:i}=await this.client.encodeContent(e,t),o=await this.createMessage(i,n,t?.timestamp),a=o.toBytes(),c={contentTopic:r,message:a,timestampNs:me(o.sent)};return new he(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a,timestamp:o.sent})))),Ve.fromV1Message(o,e,t?.contentType||K,i,r,this))))}streamMessages(e){return ye.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await Me.fromBytes(e),{senderAddress:n,recipientAddress:r}=s;if(!n||!r||!t||ke(n,r)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof de||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Te(this.peerAddress),Te(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||K,{payload:o}=await this.client.encodeContent(e,t),a=await this.createMessage(o,n,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a.toBytes(),timestamp:a.sent})))),"unknown"===this.consentState&&await this.allow(),Ve.fromV1Message(a,e,i,o,r,this)}async decryptBatch(e,t,s=!1){const n=(await this.client.keystore.decryptV1(Ee(e,this.client.publicKeyBundle))).responses,r=[];for(let i=0;i<n.length;i++){const o=n[i],a=e[i];try{const{decrypted:e}=be(o);r.push(await this.buildDecodedMessage(a,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return r}async buildDecodedMessage(e,t,s){const{content:n,contentType:r,error:i,contentFallback:o}=await this.client.decodeContent(t);return Ve.fromV1Message(e,n,r,t,s,this,i,o)}async createMessage(e,t,s){return s=s||new Date,Me.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class Ne{constructor(e,t,s,n,r,i){this.conversationVersion="v2",this.topic=t,this.createdAt=n,this.context=r,this.client=e,this.peerAddress=s,this.consentProof=i}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get consentProofPayload(){return this.consentProof}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return ye.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:i,message:r.toBytes(),timestamp:r.sent}]);const o=t?.contentType||K;return"unknown"===this.consentState&&await this.allow(),Ve.fromV2Message(r,e,o,i,s,this,this.client.address)}async createMessage(e,t,s){const n={topic:this.topic,createdNs:we(s||new Date)},r=o.MessageHeaderV2.encode(n).finish(),i=await _(pe(r,e)),c={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:i,prekeyIndex:0,identityKey:void 0})},d=a.SignedContent.encode(c).finish(),{encrypted:h,senderHmac:y}=await this.encryptMessage(d,r),u={v1:void 0,v2:{headerBytes:r,ciphertext:h,senderHmac:y,shouldPush:t}},l=o.Message.encode(u).finish();return _e.create(u,n,l,y,t)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,n=[];for(let r=0;r<s.length;r++){const i=s[r],o=e[r];try{const{decrypted:e}=be(i);n.push(await this.buildDecodedMessage(o,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return n}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:n,senderHmac:r}=be(s[0]);return{encrypted:n,senderHmac:r}}async buildDecodedMessage(e,t){const s=a.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new oe(s).verifyKey(new oe(t)))throw new Error("pre key not signed by identity key")}(s);const n=await _(pe(e.headerBytes,s.payload));if(!new oe(s.sender?.preKey).verify(new te(s.signature),n))throw new Error("invalid signature");const r=await new ce(s.sender).walletSignatureAddress(),{content:i,contentType:o,error:c,contentFallback:d}=await this.client.decodeContent(s.payload);return Ve.fromV2Message(e,i,o,this.topic,s.payload,this,r,c,d)}async prepareMessage(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=r.toBytes(),o=t?.ephemeral?this.ephemeralTopic:this.topic,a={contentTopic:o,message:i,timestampNs:me(r.sent)};return new he(a,(async()=>(await this.client.publishEnvelopes([{contentTopic:o,message:i,timestamp:r.sent}]),Ve.fromV2Message(r,e,t?.contentType||K,o,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=o.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=o.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return _e.create(t,s,e.message,t.v2.senderHmac,t.v2.shouldPush)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const De=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new N(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new N(e.v2.ciphertext)];throw new Error("unknown message version")};class xe{constructor(e,t,s){[this.headerBytes,this.ciphertext]=De(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class Me extends xe{constructor(e,t,s,n,r){super(e,t,s),this.conversation=void 0,this.senderAddress=r,this.header=n}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const n=new de(t.sender).walletSignatureAddress(),r=j(await _(s));return new Me(r,s,e,t,n)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new ae(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(Ee([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:n}=be(s[0]);return n}static fromBytes(e){const t=o.Message.decode(e),[s]=De(t),n=o.MessageHeaderV1.decode(s);if(!n)throw new Error("missing message header");if(!n.sender)throw new Error("missing message sender");if(!n.sender.identityKey)throw new Error("missing message sender identity key");if(!n.sender.preKey)throw new Error("missing message sender pre-key");if(!n.recipient)throw new Error("missing message recipient");if(!n.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!n.recipient.preKey)throw new Error("missing message recipient pre-key");return Me.create(t,n,e)}static async encode(e,t,s,n,r){const i={sender:s,recipient:n,timestamp:l.fromNumber(r.getTime())},a=o.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:n,headerBytes:a,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=be(c.responses[0]),h={v1:{headerBytes:a,ciphertext:d},v2:void 0},y=o.Message.encode(h).finish();return Me.create(h,i,y)}}class _e extends xe{constructor(e,t,s,n,r,i){super(e,t,s),this.header=n,this.senderHmac=r,this.shouldPush=i}static async create(e,t,s,n,r){const i=j(await _(s));return new _e(i,s,e,t,n,r)}get sent(){return fe(this.header.createdNs)}}class Ve{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:n,conversation:r,contentBytes:i,contentType:o,contentTopic:a,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=n,this.conversation=r,this.contentType=o,this.sent=d,this.error=h,this.content=c,this.contentTopic=a,this.contentBytes=i,this.contentFallback=y}toBytes(){return o.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:we(this.conversation.createdAt),peerAddress:this.conversation.peerAddress,consentProofPayload:this.conversation.consentProof??void 0},sentNs:we(this.sent)}).finish()}static async fromBytes(e,t){const s=o.DecodedMessage.decode(e),n=s.messageVersion;if("v1"!==n&&"v2"!==n)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:r,contentType:i,error:a,contentFallback:c}=await t.decodeContent(s.contentBytes);return new Ve({...s,content:r,contentType:i,error:a,messageVersion:n,sent:fe(s.sentNs),conversation:Ue(s.conversation,t,n),contentFallback:c})}static fromV1Message(e,t,s,n,r,i,o,a){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new Ve({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:o,contentFallback:a})}static fromV2Message(e,t,s,n,r,i,o,a,c){const{id:d,sent:h}=e;return new Ve({id:d,messageVersion:"v2",senderAddress:o,sent:h,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:a,contentFallback:c})}}function Ue(e,t,s){if("v1"===s)return new Re(t,e.peerAddress,fe(e.createdNs));if("v2"===s)return new Ne(t,e.topic,e.peerAddress,fe(e.createdNs),e.context,e.consentProofPayload);throw new Error(`Unknown conversation version ${s}`)}function Le(e,t){return t.decodeContent(e)}class qe extends Error{constructor(e){super(`no pre-key matches: ${j(e.secp256k1Uncompressed.bytes)}`)}}class Oe{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new Y(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new Y(e)))}static async generate(e){const t=await Y.generate(new ne(e)),s=new Oe({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new qe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await Y.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ce({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(n.length+r.length+o.length);return a.set(n,0),a.set(r,n.length),a.set(o,n.length+r.length),a}encode(){return t.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Oe({identityKey:Y.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>Y.fromLegacyKey(e)))})}}class Ge{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new W(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new W(e)))}static async generate(e){const t=W.generate();e&&await t.publicKey.signWithWallet(e);const s=new Ge({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new qe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=W.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new de({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(n.length+r.length+o.length);return a.set(n,0),a.set(r,n.length),a.set(o,n.length+r.length),a}encode(){return t.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function He(e){const s=t.PrivateKeyBundle.decode(e);if(s.v1)return new Ge(s.v1);if(s.v2)return new Oe(s.v2);throw new Error("unknown private key bundle version")}class Fe{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new Fe({walletAddr:e,createdNs:we(t)})}static fromBytes(e){const t=c.AuthData.decode(e);return new Fe(t)}toBytes(){return c.AuthData.encode(this).finish()}}class $e{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=Fe.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return c.Token.encode(this).finish()}static fromBytes(e){return new $e(c.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class je{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof $e?e:new $e(e))(await this.keystore.createAuthToken({timestampNs:e?we(e):void 0}))}}const Xe=e=>new Promise((t=>setTimeout(t,e))),Je=e=>!!e;async function ze(e,t,s,n,r=Je,i=1){const o="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!r(i)||o>s)throw i;return await Xe(n),ze(e,t,s,n,r,o+1)}}async function*Ye(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),n=[];for(const t of e)"fulfilled"===t.status?n.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield n}}class We{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:Qe,SortDirection:Ze}=d,et={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var tt;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(tt||(tt={}));class st extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new st(e.message,e.code)}}const nt=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),rt=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),it=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=ue(e.message)),e):e;class ot{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/12.1.0",e===et.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n")}async _query(e){try{return await ze(Qe.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw st.fromObject(e)}}_batchQuery(e){return ze(Qe.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),n=this.headers();n.set("Authorization",`Bearer ${s}`);try{return await ze(Qe.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:n}],this.maxRetries,100,rt)}catch(s){if(rt(s)||t>=1)throw st.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const n=new AbortController;return(async()=>{for(;;){const r=(new Date).getTime();try{if(await Qe.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:n.signal,mode:"cors",headers:this.headers()}),n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Xe(1e3),s?.()}catch(e){if(nt(e)||n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Xe(1e3),s?.()}}})(),{unsubscribe:async()=>{n?.abort()}}}async query(e,{direction:t=Ze.SORT_DIRECTION_ASCENDING,limit:s}){const n=[];for await(const r of this.queryIteratePages(e,{direction:t,pageSize:s&&s<100?s:100}))for(const e of r)if(n.push(e),s&&n.length===s)return n;return n}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:n,pageSize:r=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=me(t),o=me(s);let a;for(;;){const t={limit:r,direction:n,cursor:a},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:o,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(it),!s.pagingInfo?.cursor)return;a=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const n=e.slice(s,s+50),r=[];for(const e of n)r.push({contentTopics:[e.contentTopic],startTimeNs:me(e.startTime),endTimeNs:me(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||Ze.SORT_DIRECTION_ASCENDING}});const i={requests:r};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),n=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?n.push(t.envelopes.map(it)):n.push([])}return n}async publish(e){const t=[];for(const{contentTopic:s,message:n,timestamp:r}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!n.length)throw new Error("0 length messages not allowed");const e=r||new Date;t.push({contentTopic:s,timestampNs:me(e),message:Uint8Array.from(n)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(it(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new We(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class at{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new S,this.keystore=t}get protoJobType(){return function(e){const t={v1:i.JobType.JOB_TYPE_REFRESH_V1,v2:i.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":i.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,n=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),n}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:we(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(i.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(l.fromNumber(0)))return fe(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:we(e)})}}const ct=e=>Boolean(e.recipientAddress&&e.senderAddress);class dt{constructor(e){this.client=e,this.v1JobRunner=new at("v1",e.keystore),this.v2JobRunner=new at("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:we(t),topic:ke(e,this.client.address),context:void 0,consentProofPayload:void 0}))).filter((e=>Be(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),n=new Set(t.map((e=>e.topic)));for(const e of s)n.has(e.topic)||(t.push(e),n.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:l.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>Be(e.contentTopic)))}),n=[];for(const e of s)try{n.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return n}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new Ne(this.client,e.topic,e.peerAddress,fe(e.createdNs),e.context,e.consentProofPayload)}conversationReferenceToV1(e){return new Re(this.client,e.peerAddress,fe(e.createdNs))}async stream(e){const t=new Set,s=Te(this.client.address),n=Ce(this.client.address),r=[s,n];return ye.create(this.client,r,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await Me.fromBytes(e.message),n=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(n))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new Re(this.client,n,s.sent)}if(e.contentTopic===n){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=Te(this.client.address),s=Ce(this.client.address),n=new Set([t,s]),r=new Map;for(const e of await this.list())n.add(e.topic),r.set(e.topic,e);const i=(e,t)=>!n.has(e)&&(r.set(e,t),n.add(e),!0),o=await ye.create(this.client,Array.from(n.values()),(async e=>{const n=e.contentTopic;if(!n||!e.message)return null;if(n===t){const t=await Me.fromBytes(e.message);if(!ct(t))return null;const s=this.getPeerAddress(t);return new Re(this.client,s,t.sent).decodeMessage(e)}if(n===s){return(await this.decodeInvites([e],!0))[0]}const i=r.get(n);if(i instanceof Re)return i.decodeMessage(e);if(i instanceof Ne)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof Ve&&e.contentTopic===t){const t=new Re(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(n.values()):void 0}if(e instanceof Ne){return i(e.topic,e)?Array.from(n.values()):void 0}}),e),a=async function*(){for await(const e of o)if(e instanceof Ve&&(yield e),e instanceof Ne)for(const t of await e.messages())yield t}();return a.return=async()=>(await(o?.return()),{value:void 0,done:!0}),a}async getIntroductionPeers(e){const t=Te(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return Me.fromBytes(e.message)}),e),n=new Map;for(const e of s){if(!ct(e))continue;const t=this.getPeerAddress(e);if(t){const s=n.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),n.set(t,e.sent)}catch(e){continue}}}return n}async newConversation(e,t,s){const n=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(n=t,r=s.context??void 0,n?.conversationId===r?.conversationId);var n,r},r=(await this.getV2ConversationsFromKeystore()).find(n);if(r)return r;let i=await this.client.getUserContact(e);if(!i)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(i instanceof de&&!t?.conversationId)return new Re(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(i instanceof de||i.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}return i instanceof de&&(i=ce.fromLegacyBundle(i)),this.v2JobRunner.run((async e=>{const r=(await this.updateV2Conversations(e)).find(n);return r||this.createV2Convo(i,t,s)}))}async createV2Convo(e,t,s){const n=new Date,{payload:r,conversation:i}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:we(n),consentProof:s});if(!r||!i)throw new Error("Required field not returned from Keystore");const o=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ce(o),message:r,timestamp:n},{contentTopic:Ce(this.client.address),message:r,timestamp:n}]),await this.client.contacts.allow([o]),this.conversationReferenceToV2(i)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}class ht{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new ht(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class yt{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class ut extends ht{static create(){return new ht(new yt)}}class lt extends Error{}class pt{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=Fe.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),r=f(t),i=await this.identityKey.sign(v(r));return new $e(c.Token.fromPartial({identityKey:n.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:s.Signature.fromPartial(i)}))}}const wt=new(0,T.ec)("secp256k1"),ft=D.subtle,mt=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),gt=Buffer.alloc(32,0);function vt(e,t){if(!e)throw new Error(t||"Assertion failed")}function bt(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(gt)>0&&e.compare(mt)<0);var t}function Et(e){const t=new Uint8Array(e);return D.getRandomValues(t),Buffer.from(t)}async function Kt(e){const t=await ft.digest("SHA-512",e);return Buffer.from(t)}function kt(e){return function(t,s,n){return new Promise((function(r){return ft.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const r={name:"AES-CBC",iv:t};return ft[e](r,s,n)})).then((function(e){r(Buffer.from(new Uint8Array(e)))}))}))}}const At=kt("encrypt"),St=kt("decrypt");async function Tt(e,t){const s=await ft.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await ft.sign({name:"HMAC",hash:"SHA-256"},s,t))}function Ct(e){return vt(32===e.length,"Bad private key"),vt(bt(e),"Bad private key"),Buffer.from(wt.keyFromPrivate(e).getPublic("array"))}function Pt(e,t){return new Promise((function(s){vt(Buffer.isBuffer(e),"Bad private key"),vt(Buffer.isBuffer(t),"Bad public key"),vt(32===e.length,"Bad private key"),vt(bt(e),"Bad private key"),vt(65===t.length||33===t.length,"Bad public key"),65===t.length&&vt(4===t[0],"Bad public key"),33===t.length&&vt(2===t[0]||3===t[0],"Bad public key");const n=wt.keyFromPrivate(e),r=wt.keyFromPublic(t),i=n.derive(r.getPublic());s(Buffer.from(i.toArray()))}))}async function It(e,t){const s=await Pt(e,t.ephemeralPublicKey),n=await Kt(s),r=n.slice(0,32),i=n.slice(32),o=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return vt(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let n=0;n<e.length;n++)s|=e[n]^t[n];return 0===s}(await Tt(e,t),s)}(i,o,t.mac),"Bad mac"),St(t.iv,r,t.ciphertext)}async function Bt(e,t){await C();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return P(s,n,t)}async function Rt(e,t){await C();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return I(s,n,t)}class Nt{constructor({topic:e,context:t,aes256GcmHkdfSha256:s,consentProof:n}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s,this.consentProof=n}static createRandom(e,t){const s=Ae(Buffer.from(D.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),n=D.getRandomValues(new Uint8Array(32));return new Nt({topic:s,aes256GcmHkdfSha256:{keyMaterial:n},context:e,consentProof:t})}toBytes(){return h.InvitationV1.encode(this).finish()}static fromBytes(e){return new Nt(h.InvitationV1.decode(e))}}class Dt{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new ce(e),this.recipient=new ce(t),this.createdNs=s}toBytes(){return h.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new Dt(h.SealedInvitationHeaderV1.decode(e))}}class xt{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new N(t)}get header(){return this._header||(this._header=Dt.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const n=await U(this.ciphertext,s,this.headerBytes);return this._invitation=Nt.fromBytes(n),this._invitation}toBytes(){return h.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new xt(h.SealedInvitationV1.decode(e))}}class Mt{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new xt(e)}toBytes(){return h.SealedInvitation.encode(this).finish()}static fromBytes(e){return new Mt(h.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=Mt.fromBytes(e.message),s=l.fromString(e.timestampNs),n=t.v1?.header.createdNs;if(!n||!n.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:n}){const r=new Dt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:we(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),o=n.toBytes(),a=await V(o,i,r);return new Mt({v1:{headerBytes:r,ciphertext:a}})}}const _t=(e,t)=>e instanceof ve?e:new ve(t,e.message),Vt=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:_t(e,s)}}}))),Ut=e=>e instanceof de?e:new de(e),Lt=(e,t,s)=>{for(const s of t)if(!e[s])throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},qt=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},Ot=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t,consentProofPayload:e.consentProof});class Gt{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new S,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new Gt(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?function(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,function(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,n]of Object.entries(e.topics))t.set(s,n);return t})(i.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...n}=s;this.topicMap.has(e)||(this.topicMap.set(e,n),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return i.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class Ht extends Gt{static async create(e){const t=new Ht(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const Ft=async(e,t,s,n)=>V(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),n),{ErrorCode:$t}=i,jt=(new TextEncoder).encode("__XMTP__INVITATION__SALT__XMTP__");class Xt{constructor(e,t,s,n){this.v1Keys=e,this.v2Keys=Oe.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.authenticator=new pt(e.identityKey),this.jobStatePersistence=n}static async create(e,t){return new Xt(e,await Ht.create(t),await Gt.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:n,isSender:r}=e,i=await(async(e,t,s,n,r)=>U(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!r),n))(this.v1Keys,Ut(s),t,n,r);return{decrypted:i}}),i.ErrorCode.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new ve(i.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const o=await((e,t,s)=>U(e,t,s))(t,qt(r.invitation),s);return{decrypted:o}}),$t.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:n}=e;return{encrypted:await Ft(this.v1Keys,Ut(t),s,n)}}),$t.ERROR_CODE_UNSPECIFIED);return i.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?fe(e):void 0)}async selfEncrypt(e){const t=await Vt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new ve($t.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await Bt(this.v1Keys.identityKey,t)}}),$t.ERROR_CODE_INVALID_INPUT);return i.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await Vt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new ve($t.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await Rt(this.v1Keys.identityKey,t)}}),$t.ERROR_CODE_INVALID_INPUT);return i.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){await C();const t=e.secp256k1.bytes;return B(t)}(this.v1Keys.identityKey);return i.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new ve($t.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=qt(r.invitation),o=await((e,t,s)=>V(e,t,s))(t,i,s),a=`${Math.floor(Date.now()/1e3/60/60/24/30)}-${await this.getAccountAddress()}`;return{encrypted:o,senderHmac:await G(i,(new TextEncoder).encode(a),s)}}),$t.ERROR_CODE_INVALID_INPUT);return i.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await Vt(e.requests,(async({payload:e,timestampNs:s})=>{const n=Mt.fromBytes(e);if(n.v1){if(!n.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=n.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),r=await n.v1.getInvitation(this.v2Keys),i={invitation:r,createdNs:n.v1.header.createdNs,peerAddress:e?await n.v1.header.recipient.walletSignatureAddress():await n.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:r.topic}),{conversation:Ot(i)}}}),$t.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),i.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{Lt(e,["recipient"],[]);const s=fe(e.createdNs),n=(t=e.recipient)instanceof ce?t:new ce(t),r=await this.getAccountAddress(),o=await n.walletSignatureAddress(),a=await this.v2Keys.sharedSecret(n,this.v2Keys.getCurrentPreKey().publicKey,r<o),c=[r,o].sort(),d=(e.context?.conversationId||"")+c.join(),h=(new TextEncoder).encode(d),y=j(await Tt(Buffer.from(a),Buffer.from(h))),u=["0",...c].join("|"),l=(new TextEncoder).encode(u),p=await async function(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:jt,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(a,l),w=new Uint8Array(await D.subtle.exportKey("raw",p)),f=new Nt({topic:Ae(y),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context,consentProof:e.consentProof}),m=await Mt.createV1({sender:this.v2Keys,recipient:n,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await n.walletSignatureAddress()};return await this.v2Store.add([g]),i.CreateInviteResponse.fromPartial({conversation:Ot(g),payload:m.toBytes()})}catch(e){throw _t(e,$t.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){Lt(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:n}=e;let r;if(s)r=this.v1Keys.identityKey;else{if(void 0===n||!Number.isInteger(n))throw new ve($t.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(r=this.v1Keys.preKeys[n],!r)throw new ve($t.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return r.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:ke(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>Ot(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),i.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===i.JobType.JOB_TYPE_UNSPECIFIED)throw new ve($t.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return i.GetRefreshJobResponse.fromPartial({lastRunNs:t||l.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:ke(e.peerAddress,this.walletAddress),context:void 0,consentProofPayload:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return l.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}async getV2ConversationHmacKeys(e){const t=Math.floor(Date.now()/1e3/60/60/24/30),s={};let n=this.v2Store.topics;return e?.topics&&(n=n.filter((t=>void 0!==t.invitation&&e.topics.includes(t.invitation.topic)))),await Promise.all(n.map((async e=>{if(e.invitation?.topic){const n=qt(e.invitation),r=await Promise.all([t-1,t,t+1].map((async e=>{const t=`${e}-${await this.getAccountAddress()}`,s=await O(n,(new TextEncoder).encode(t));return{thirtyDayPeriodsSinceEpoch:e,hmacKey:await F(s)}})));s[e.invitation.topic]={values:r}}}))),{hmacKeys:s}}}class Jt{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:d.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return Pe(e)}}class zt{constructor({eciesBytes:t,signature:s}){if(!t||!t.length)throw new Error("eciesBytes is empty");if(!s)throw new Error("signature is undefined");this.eciesBytes=t,this.signature=new te(s),this.ciphertext=e.SignedEciesCiphertext_Ecies.decode(t)}toBytes(){return e.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await _(this.eciesBytes))}static fromBytes(t){const s=e.SignedEciesCiphertext.decode(t);return new zt(s)}static async create(t,s){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(t);const n=e.SignedEciesCiphertext_Ecies.encode(t).finish(),r=await s.sign(await _(n));return new zt({eciesBytes:n,signature:r})}}class Yt{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=Ct(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const n=s?.iv||Et(16);let r=s?.ephemPrivateKey||Et(32);for(;!bt(r);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");r=Et(32)}const i=Ct(r),o=await Kt(await Pt(r,e)),a=o.slice(0,32),c=o.slice(32),d=await At(n,a,t),h=Buffer.concat([n,i,d]);return{iv:n,ephemeralPublicKey:i,ciphertext:d,mac:await Tt(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await It(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await zt.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=zt.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}class Wt{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}const Qt=async(e,t)=>{if(!e.persistConversations)return ut.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),n=`xmtp/${e.env}/${s}/`;const r=e.basePersistence,i=!e.disablePersistenceEncryption;return new Wt(n,i?new Yt(r,t.identityKey):r)},Zt="key_bundle";class es{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(e){let t=await this.signer.getAddress();return t=m(t),`${t}/${e}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(Zt));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(Zt),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new pt(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,s){const n=e.encode(),r=D.getRandomValues(new Uint8Array(32)),i=ss(r),o=await s.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const a=await s.signMessage(i);if(!E({address:o,message:i,signature:a}))throw new Error("invalid signature");const c=v(a),d=await V(n,c);return t.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:r,ciphertext:d}}).finish()}async fromEncryptedBytes(e,s){const[n,r]=function(e){try{const s=t.EncryptedPrivateKeyBundle.decode(e);if(s.v1)return[s.v1,!1]}catch(s){return[t.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(s);if(!n.walletPreKey)throw new Error("missing wallet pre-key");if(!n.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=v(await e.signMessage(ss(n.walletPreKey)));try{const e=new N(n.ciphertext),t=await U(e,i),[s,o]=ts(t);return[s,r||o]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let s=i.slice(0,i.length-1);s=t<27?new Uint8Array([...s,t+27]):new Uint8Array([...s,t-27]);const o=new N(n.ciphertext),a=await U(o,s),[c,d]=ts(a);return[c,r||d]}}}function ts(e){try{const t=He(e);if(t instanceof Oe)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(s){const n=t.PrivateKeyBundleV1.decode(e);return[new Ge(n),!0]}}function ss(e){return`XMTP : Enable Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}class ns{async newKeystore(e,t,s){if(!s)throw new lt("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const n=await Ge.generate(s),r=new es(s,new Jt(t),e.preEnableIdentityCallback);return await r.storePrivateKeyBundle(n),Xt.create(n,await Qt(e,n))}}class rs{async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");const n=new es(s,new Jt(t),e.preEnableIdentityCallback),r=await n.loadPrivateKeyBundle();if(!r)throw new lt("No keys found");return Xt.create(r,await Qt(e,r))}}function is(){return window.ethereum}function os(e){const[t,s,...n]=e.split(".");return{major:Number(t),minor:Number(s),patch:n.join(".")}}function as(e,t){if(!e||!t)return!1;const s=os(e),n=os(t);return s.major!==n.major?s.major>n.major:s.minor!==n.minor?s.minor>n.minor:!(!s.patch||!n.patch)&&function(e,t){const[s,n]=e.split("-"),[r,i]=t.split("-");if(Number(s)!==Number(r))return Number(s)>Number(r);if(!n||!i)return!1;const[o,a]=n.split("."),[c,d]=i.split(".");if(o!==c)return!0;return Number(a)>Number(d)}(s.patch,n.patch)}const{GetKeystoreStatusResponse_KeystoreStatus:cs,InitKeystoreRequest:ds,InitKeystoreResponse:hs,GetKeystoreStatusRequest:ys,GetKeystoreStatusResponse:us}=i;async function ls(e,t,s,n,r){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=le(e,0,e.length)}const o=await async function(e,t,s,n){const r={meta:s};"string"==typeof t&&(r.req=t);const i=await(is()?.request({method:"wallet_invokeSnap",params:{snapId:n,request:{method:e,params:r}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,n,r);if(Array.isArray(o))throw new Error("Unexpected array response");return t.res.decode(ue(o))}async function ps(){const e=is();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function ws(e,t){try{const s=await async function(){return await(is()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(n=s.version,r=t,!n||!r||os(n).major===os(r).major));var n,r})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const fs={req:ys,res:us};const ms={req:ds,res:hs};const gs={decryptV1:{req:i.DecryptV1Request,res:i.DecryptResponse},decryptV2:{req:i.DecryptV2Request,res:i.DecryptResponse},encryptV1:{req:i.EncryptV1Request,res:i.EncryptResponse},encryptV2:{req:i.EncryptV2Request,res:i.EncryptResponse},saveInvites:{req:i.SaveInvitesRequest,res:i.SaveInvitesResponse},createInvite:{req:i.CreateInviteRequest,res:i.CreateInviteResponse},createAuthToken:{req:i.CreateAuthTokenRequest,res:c.Token},signDigest:{req:i.SignDigestRequest,res:s.Signature},getPublicKeyBundle:{req:null,res:n.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:t.PrivateKeyBundleV1},saveV1Conversations:{req:i.SaveV1ConversationsRequest,res:i.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:i.GetConversationsResponse},getV2Conversations:{req:null,res:i.GetConversationsResponse},getRefreshJob:{req:i.GetRefreshJobRequest,res:i.GetRefreshJobResponse},setRefreshJob:{req:i.SetRefeshJobRequest,res:i.SetRefreshJobResponse},selfEncrypt:{req:i.SelfEncryptRequest,res:i.SelfEncryptResponse},selfDecrypt:{req:i.SelfDecryptRequest,res:i.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:i.GetPrivatePreferencesTopicIdentifierResponse},getV2ConversationHmacKeys:{req:i.GetConversationHmacKeysRequest,res:i.GetConversationHmacKeysResponse}},vs={...gs,getKeystoreStatus:{req:i.GetKeystoreStatusRequest,res:i.GetKeystoreStatusResponse},initKeystore:{req:i.InitKeystoreRequest,res:i.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:bs}=i;class Es{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");if(!await ps())throw new lt("MetaMask with Snaps not detected");const n=await s.getAddress(),r=e.env,i=await ws(this.snapId,this.snapVersion);if(i&&!as(this.snapVersion,i.version)||await async function(e,t={}){await(is()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const n=await async function(e,t){const s=await ls("getKeystoreStatus",fs,{walletAddress:e.walletAddress},e,t);if([cs.KEYSTORE_STATUS_UNSPECIFIED,cs.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(n===bs.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(n,r,this.snapId)){const n=await async function(e,t,s){if(e.privateKeyOverride){const t=He(e.privateKeyOverride);if(!(t instanceof Ge))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const n=new rs;try{const r=await n.newKeystore(e,t,s);return new Ge(await r.getPrivateKeyBundle())}catch(n){if(n instanceof lt)return async function(e,t,s){const n=new ns,r=await n.newKeystore(e,t,s);return new Ge(await r.getPrivateKeyBundle())}(e,t,s);throw n}}(e,t,s)}(e,t,s);await async function(e,t,s){const n=e.identityKey.publicKey.walletSignatureAddress(),r=await ls("initKeystore",ms,{v1:e},{walletAddress:n,env:t},s);if(r.error)throw new ve(r.error.code,r.error.message)}(n,r,this.snapId)}return function(e,t,s){const n={},r={walletAddress:e,env:t};for(const[e,t]of Object.entries(vs))n[e]=async n=>t.req?ls(e,t,n,r,s):ls(e,t,void 0,r,s);return{...n,getAccountAddress:async()=>e}}(n,r,this.snapId)}}class Ks{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new lt("No private key override provided");const s=He(t);if(s instanceof Oe)throw new Error("V2 private key bundle found. Only V1 supported");return Xt.create(s,await Qt(e,s))}}function ks(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}function As(e){if(e===a.Compression.COMPRESSION_GZIP)return"gzip";if(e===a.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function Ss(e,t=1024){let s=0;return new ReadableStream({pull(n){if(s>=e.length)return n.close();let r=s+t;r=r<=e.length?r:e.length,n.enqueue(e.subarray(s,r)),s=r}})}function Ts(e,t){let s=0;return new WritableStream({write(n){const r=s+n.length;if(r>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<r;)e.bytes=Cs(e.bytes,t);e.bytes.set(n,s),s=r},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function Cs(e,t){let s=2*e.length;s>t&&(s=t);const n=new Uint8Array(s);return n.set(e),n}function Ps(e){let t;try{t=y.ContactBundle.decode(e)}catch(s){const r=n.PublicKeyBundle.decode(e);t={v1:{keyBundle:new de(r)},v2:void 0}}if(t.v1?.keyBundle)return new de(t.v1.keyBundle);if(t.v2?.keyBundle)return new ce(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function Is(e){return e instanceof de?y.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():y.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}class Bs{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new Bs(e,"address",t)}static fromGroupId(e,t="unknown"){return new Bs(e,"groupId",t)}static fromInboxId(e,t="unknown"){return new Bs(e,"inboxId",t)}}class Rs{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=Bs.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=Bs.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}allowGroup(e){const t=Bs.fromGroupId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyGroup(e){const t=Bs.fromGroupId(e,"denied");return this.entries.set(t.key,"denied"),t}allowInboxId(e){const t=Bs.fromInboxId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyInboxId(e){const t=Bs.fromInboxId(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=Bs.fromAddress(e);return this.entries.get(t.key)??"unknown"}groupState(e){const t=Bs.fromGroupId(e);return this.entries.get(t.key)??"unknown"}inboxIdState(e){const t=Bs.fromInboxId(e);return this.entries.get(t.key)??"unknown"}async getIdentifier(){if(!this._identifier){const{identifier:e}=await this.client.keystore.getPrivatePreferencesTopicIdentifier();this._identifier=e}return this._identifier}async decodeMessages(e){const{responses:t}=await this.client.keystore.selfDecrypt({requests:e.map((e=>({payload:e})))});return t.reduce(((e,t)=>t.result?.decrypted?e.concat(u.PrivatePreferencesAction.decode(t.result.decrypted)):e),[])}processActions(e,t){const s=[];return e.forEach((e=>{e.allowAddress?.walletAddresses.forEach((e=>{s.push(this.allow(e))})),e.denyAddress?.walletAddresses.forEach((e=>{s.push(this.deny(e))})),e.allowGroup?.groupIds.forEach((e=>{s.push(this.allowGroup(e))})),e.denyGroup?.groupIds.forEach((e=>{s.push(this.denyGroup(e))})),e.allowInboxId?.inboxIds.forEach((e=>{s.push(this.allowInboxId(e))})),e.denyInboxId?.inboxIds.forEach((e=>{s.push(this.denyInboxId(e))}))})),t&&(this.lastEntryTimestamp=ge(t)),s}async stream(e){const t=await this.getIdentifier(),s=Ie(t);return ye.create(this.client,[s],(async e=>{if(!e.message)return;const t=await this.decodeMessages([e.message]);return this.processActions(t,e.timestampNs),t[0]}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.getIdentifier(),s=Ie(t);let n;const r=await this.client.listEnvelopes(s,(async({message:e,timestampNs:t})=>(t&&(n=t),e)),{startTime:e}),i=await this.decodeMessages(r);return this.processActions(i,n)}async publish(e){const t=await this.getIdentifier(),s=e.reduce(((e,t)=>{let s,n,r;if("unknown"===t.permissionType)return e;switch(t.entryType){case"address":s="allowed"===t.permissionType?"allowAddress":"denyAddress",n="walletAddresses",r=e[s]?.[n]??[];break;case"groupId":s="allowed"===t.permissionType?"allowGroup":"denyGroup",n="groupIds",r=e[s]?.[n]??[];break;case"inboxId":s="allowed"===t.permissionType?"allowInboxId":"denyInboxId",n="inboxIds",r=e[s]?.[n]??[];break;default:return e}return{...e,[s]:{[n]:[...r,t.value]}}}),{}),n=u.PrivatePreferencesAction.encode(s).finish(),{responses:r}=await this.client.keystore.selfEncrypt({requests:[{payload:n}]}),i=r.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),o=Ie(t),a=new Date,c=i.map((e=>({contentTopic:o,message:e,timestamp:a})));await this.client.publishEnvelopes(c),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class Ns{constructor(e){this.addresses=new Set,this.consentList=new Rs(e),this.client=e,this.jobRunner=new at("user-preferences",e.keystore)}validateConsentSignature({signature:e,timestamp:t},s){const n=Number(t);if(!e||!n)return!1;if(n>Date.now())return!1;if(n<Date.now()-2592e6)return!1;const r=J(e),i=R(s,n),o=ee(v(b(i)),r);return o?.getEthereumAddress()===this.client.address}async loadConsentList(e){return this.jobRunner.run((async t=>{const s=await this.consentList.load(e??t);try{const e=(await this.client.conversations.list()).reduce(((e,t)=>t.consentProof&&"unknown"===this.consentState(t.peerAddress)&&this.validateConsentSignature(t.consentProof,t.peerAddress)?e.concat(t.peerAddress):e),[]);e.length&&await this.client.contacts.allow(e)}catch(e){console.log(e)}return s}))}async refreshConsentList(){return this.consentList.reset(),await this.jobRunner.resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return this.consentList.stream(e)}get lastConsentListEntryTimestamp(){return this.consentList.lastEntryTimestamp}setConsentListEntries(e){e.length&&(this.consentList.reset(),e.forEach((e=>{"allowed"===e.permissionType&&this.consentList.allow(e.value),"denied"===e.permissionType&&this.consentList.deny(e.value)})))}isAllowed(e){return"allowed"===this.consentList.state(e)}isDenied(e){return"denied"===this.consentList.state(e)}isGroupAllowed(e){return"allowed"===this.consentList.groupState(e)}isGroupDenied(e){return"denied"===this.consentList.groupState(e)}isInboxAllowed(e){return"allowed"===this.consentList.inboxIdState(e)}isInboxDenied(e){return"denied"===this.consentList.inboxIdState(e)}consentState(e){return this.consentList.state(e)}groupConsentState(e){return this.consentList.groupState(e)}inboxConsentState(e){return this.consentList.inboxIdState(e)}async allow(e){await this.consentList.publish(e.map((e=>Bs.fromAddress(e,"allowed"))))}async deny(e){await this.consentList.publish(e.map((e=>Bs.fromAddress(e,"denied"))))}async allowGroups(e){await this.consentList.publish(e.map((e=>Bs.fromGroupId(e,"allowed"))))}async denyGroups(e){await this.consentList.publish(e.map((e=>Bs.fromGroupId(e,"denied"))))}async allowInboxes(e){await this.consentList.publish(e.map((e=>Bs.fromInboxId(e,"allowed"))))}async denyInboxes(e){await this.consentList.publish(e.map((e=>Bs.fromInboxId(e,"denied"))))}}var Ds;!function(e){e[e.none=0]="none",e[e.xmtpTopicStore=1]="xmtpTopicStore"}(Ds||(Ds={}));const xs=Ds.none;class Ms{static createConfiguration(){return{type:xs,version:0}}constructor(e){this.configuration=e}get backupType(){return xs}}const _s=Ds.xmtpTopicStore;class Vs{static createConfiguration(e){return{type:_s,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return _s}}async function Us(e,t){const s=await async function(e,t){let s;switch((await t()).type){case Ds.none:s=Ms.createConfiguration();break;case Ds.xmtpTopicStore:s=Vs.createConfiguration(e)}return s}(e,t);switch(s.type){case Ds.none:return new Ms(s);case Ds.xmtpTopicStore:return new Vs(s)}}const{Compression:Ls}=a,qs=104857600;class Os{constructor(e,t,s,n){this.knownPublicKeyBundles=new Map,this.keystore=n,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new dt(this),this._codecs=new Map,this._maxContentSize=qs,this.apiClient=t,this._backupClient=s,this.contacts=new Ns(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return ce.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=ks(e),n=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new k],maxContentSize:qs,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?ht.create():ut.create(),disablePersistenceEncryption:!1,keystoreProviders:$s(),apiClientFactory:Gs};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Es("npm:@xmtp/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),r=n.apiClientFactory(n),i=await async function(e,t,s){for(const n of e.keystoreProviders)try{return await n.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof lt)continue;throw e}throw new Error("No keystore providers available")}(n,r,s),o=new de(await i.getPublicKeyBundle()),a=o.walletSignatureAddress();r.setAuthenticator(new je(i));const c=await Os.setupBackupClient(a,n.env),d=new Os(o,r,c,i);return await d.init(n),d}static async getKeys(e,t){const s=await Os.create(ks(e),t),n=await s.keystore.getPrivateKeyBundle();return new Ge(n).encode()}static isSnapsReady(){return ps()}static async setupBackupClient(e,t){return Us(e,(async()=>Promise.resolve({type:"local"===t?Ds.xmtpTopicStore:Ds.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await Hs(this.apiClient,this.address);t&&t instanceof ce&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:Se(this.address),message:Is(t)}])}async getUserContact(e){e=m(e);const t=this.knownPublicKeyBundles.get(e);if(t)return t;const s=await Hs(this.apiClient,e);return s&&this.knownPublicKeyBundles.set(e,s),s}async getUserContacts(e){const t=e.map((e=>m(e))),s=new Map,n=[];for(const e of t){const t=this.knownPublicKeyBundles.get(e);t?s.set(e,t):(s.set(e,void 0),n.push(e))}const r=await Fs(this.apiClient,n);for(let e=0;e<r.length;e++){const t=n[e],i=r[e];s.set(t,i),i&&this.knownPublicKeyBundles.set(t,i)}return t.map((e=>s.get(e)))}forgetContact(e){e=m(e),this.knownPublicKeyBundles.delete(e)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(e,t){const s=t?.apiUrl||et[t?.env||"dev"],n=new ot(s,{appVersion:t?.appVersion});if(Array.isArray(e)){const t=e.map((e=>m(e)));return(await Fs(n,t)).map((e=>!!e))}try{e=m(e)}catch(e){return!1}return void 0!==await Hs(n,e)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||K,n=this.codecFor(s);if(!n)throw new Error("unknown content type "+s);const r=n.encode(e,this),i=n.fallback(e);return i&&(r.fallback=i),"number"==typeof t?.compression&&r.content.length>=10&&(r.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await Ss(e.content).pipeThrough(new CompressionStream(As(e.compression))).pipeTo(Ts(t,e.content.length+1e3)),e.content=t.bytes}(r),{payload:a.EncodedContent.encode(r).finish(),shouldPush:n.shouldPush(e)}}async decodeContent(e){const t=a.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const n=new A(t.type);let r;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await Ss(e.content).pipeThrough(new DecompressionStream(As(e.compression))).pipeTo(Ts(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(n);return i?s=i.decode(t,this):r=new Error("unknown content type "+n),{content:s,contentType:n,error:r,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ce(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:n,endTime:r,limit:i}=s,o=await this.apiClient.query({contentTopic:e,startTime:n,endTime:r},{direction:s.direction||d.SortDirection.SORT_DIRECTION_ASCENDING,limit:i}),a=[];for(const e of o)if(e.message)try{const s=await t(e);a.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return a}listEnvelopesPaginated(e,t,s){return Ye(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function Gs(e){const t=e.apiUrl||et[e.env];return new ot(t,{appVersion:e.appVersion})}async function Hs(e,t){const s=e.queryIterator({contentTopic:Se(t)},{pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=Ps(e.message);let n;try{n=await(s?.walletSignatureAddress())}catch(e){n=void 0}if(n?.toLowerCase()===t.toLowerCase())return s}}async function Fs(e,t){const s=t.map(Se),n=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=n[t];if(s)for(const t of s)if(t.message)try{const s=Ps(t.message),n=await(s?.walletSignatureAddress());if(e.toLowerCase()===n.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function $s(){return[new Ks,new rs,new ns]}export{et as ApiUrls,We as AuthCache,ht as BrowserStoragePersistence,N as Ciphertext,Os as Client,Ls as Compression,Bs as ConsentListEntry,Re as ConversationV1,Ne as ConversationV2,dt as Conversations,Ve as DecodedMessage,Yt as EncryptedPersistence,ot as HttpApiClient,Xt as InMemoryKeystore,ut as InMemoryPersistence,Nt as InvitationV1,ns as KeyGeneratorKeystoreProvider,pt as LocalAuthenticator,Me as MessageV1,_e as MessageV2,rs as NetworkKeystoreProvider,Wt as PrefixedPersistence,W as PrivateKey,Ge as PrivateKeyBundleV1,Oe as PrivateKeyBundleV2,ae as PublicKey,de as PublicKeyBundle,Mt as SealedInvitation,te as Signature,oe as SignedPublicKey,ce as SignedPublicKeyBundle,Es as SnapProvider,Ze as SortDirection,Ks as StaticKeystoreProvider,ye as Stream,Ke as buildContentTopic,ke as buildDirectMessageTopic,Ae as buildDirectMessageTopicV2,Se as buildUserContactTopic,Te as buildUserIntroTopic,Ce as buildUserInviteTopic,Pe as buildUserPrivateStoreTopic,we as dateToNs,Ps as decodeContactBundle,Le as decodeContent,U as decrypt,$s as defaultKeystoreProviders,V as encrypt,F as exportHmacKey,ge as fromNanoString,G as generateHmacSignature,O as hkdfHmacKey,$ as importHmacKey,gs as keystoreApiDefs,Ye as mapPaginatedStream,fe as nsToDate,ze as retry,vs as snapKeystoreApiDefs,me as toNanoString,H as verifyHmacSignature};
+import{ciphertext as e,privateKey as t,signature as s,publicKey as n,fetcher as r,keystore as i,message as o,content as a,authn as c,messageApi as d,invitation as h,contact as y,privatePreferences as u}from"@xmtp/proto";import l from"long";import*as p from"@noble/secp256k1";import{bytesToHex as w,keccak256 as f,getAddress as m,hexToSignature as g,hexToBytes as v,hashMessage as b,verifyMessage as E}from"viem";import{ContentTypeText as K,TextCodec as k}from"@xmtp/content-type-text";import{ContentTypeId as A}from"@xmtp/content-type-primitives";import{Mutex as S}from"async-mutex";import T from"elliptic";import C,{user_preferences_encrypt as P,user_preferences_decrypt as I,generate_private_preferences_topic as B}from"@xmtp/user-preferences-bindings-wasm/web";import{createConsentMessage as R}from"@xmtp/consent-proof-signature";class N{constructor(e){if(!e.aes256GcmHkdfSha256)throw new Error("invalid ciphertext");if(e.aes256GcmHkdfSha256.payload.length<16)throw new Error(`invalid ciphertext ciphertext length: ${e.aes256GcmHkdfSha256.payload.length}`);if(32!==e.aes256GcmHkdfSha256.hkdfSalt.length)throw new Error(`invalid ciphertext salt length: ${e.aes256GcmHkdfSha256.hkdfSalt.length}`);if(12!==e.aes256GcmHkdfSha256.gcmNonce.length)throw new Error(`invalid ciphertext nonce length: ${e.aes256GcmHkdfSha256.gcmNonce.length}`);this.aes256GcmHkdfSha256=e.aes256GcmHkdfSha256}toBytes(){return e.Ciphertext.encode(this).finish()}static fromBytes(t){return new N(e.Ciphertext.decode(t))}}const D=self.crypto,x=(new Uint8Array).buffer,M=(new Uint8Array).buffer;async function _(e){return new Uint8Array(await D.subtle.digest("SHA-256",e))}async function V(e,t,s){const n=D.getRandomValues(new Uint8Array(32)),r=D.getRandomValues(new Uint8Array(12)),i=await q(t,n),o=await D.subtle.encrypt(L(r,s),i,e);return new N({aes256GcmHkdfSha256:{payload:new Uint8Array(o),hkdfSalt:n,gcmNonce:r}})}async function U(e,t,s){if(!e.aes256GcmHkdfSha256)throw new Error("invalid payload ciphertext");const n=await q(t,e.aes256GcmHkdfSha256.hkdfSalt),r=await D.subtle.decrypt(L(e.aes256GcmHkdfSha256.gcmNonce,s),n,e.aes256GcmHkdfSha256.payload);return new Uint8Array(r)}function L(e,t){const s={name:"AES-GCM",iv:e};return t&&(s.additionalData=t),s}async function q(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:t,info:x},s,{name:"AES-GCM",length:256},!1,["encrypt","decrypt"])}async function O(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:M,info:t},s,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}async function G(e,t,s){const n=await O(e,t),r=await D.subtle.sign("HMAC",n,s);return new Uint8Array(r)}async function H(e,t,s){return await D.subtle.verify("HMAC",e,t,s)}async function F(e){const t=await D.subtle.exportKey("raw",e);return new Uint8Array(t)}async function $(e){return D.subtle.importKey("raw",e,{name:"HMAC",hash:"SHA-256",length:256},!0,["sign","verify"])}const j=p.utils.bytesToHex;function X(e,t){if(e.length!==t.length)return!1;for(let s=0;s<e.length;s++)if(e[s]!==t[s])return!1;return!0}function J(e){const t=g(e),s=v(t.r),n=v(t.s);let r=Number(t.v);0!==r&&1!==r||(r+=27);const i=1-r%2,o=new Uint8Array(64);return o.set(s),o.set(n,s.length),{bytes:o,recovery:i}}function z(e){if(32!==e.bytes.length)throw new Error(`invalid private key length: ${e.bytes.length}`)}class Y{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.secp256k1=e.secp256k1,this.createdNs=e.createdNs,!e.publicKey)throw new Error("missing public key");this.publicKey=new oe(e.publicKey)}static async generate(e){const t={bytes:p.utils.randomPrivateKey()},s=l.fromNumber((new Date).getTime()).mul(1e6),n=new ie({secp256k1Uncompressed:{bytes:p.getPublicKey(t.bytes)},createdNs:s}),r=await e.signKey(n);return new Y({secp256k1:t,createdNs:s,publicKey:r})}generated(){return new Date(this.createdNs.div(1e6).toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=e.toBytes(),s=await _(t),n=await this.sign(s);return new oe({keyBytes:t,signature:n})}static async signerKey(e,t){return ee(await _(e.bytesToSign()),t)}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}equals(e){return X(this.secp256k1.bytes,e.secp256k1.bytes)&&this.publicKey.equals(e.publicKey)}toBytes(){return t.SignedPrivateKey.encode(this).finish()}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}static fromBytes(e){return new Y(t.SignedPrivateKey.decode(e))}static fromLegacyKey(e,t){return new Y({createdNs:e.timestamp.mul(1e6),secp256k1:e.secp256k1,publicKey:oe.fromLegacyKey(e.publicKey,t)})}}class W{constructor(e){if(!e.secp256k1)throw new Error("invalid private key");if(z(e.secp256k1),this.timestamp=e.timestamp,this.secp256k1=e.secp256k1,!e.publicKey)throw new Error("missing public key");this.publicKey=new ae(e.publicKey)}static generate(){const e={bytes:p.utils.randomPrivateKey()},t=l.fromNumber((new Date).getTime());return new W({secp256k1:e,timestamp:t,publicKey:new ae({secp256k1Uncompressed:{bytes:p.getPublicKey(e.bytes)},timestamp:t})})}generated(){return new Date(this.timestamp.toNumber())}async sign(e){const[t,s]=await p.sign(e,this.secp256k1.bytes,{recovered:!0,der:!1});return new te({ecdsaCompact:{bytes:t,recovery:s}})}async signKey(e){const t=await _(e.bytesToSign());return e.signature=await this.sign(t),e}sharedSecret(e){return p.getSharedSecret(this.secp256k1.bytes,e.secp256k1Uncompressed.bytes,!1)}encrypt(e,t,s){return V(e,this.sharedSecret(t),s)}decrypt(e,t,s){return U(e,this.sharedSecret(t),s)}matches(e){return this.publicKey.equals(e)}validatePublicKey(){return X(p.getPublicKey(this.secp256k1.bytes),this.publicKey.secp256k1Uncompressed.bytes)}toBytes(){return t.PrivateKey.encode(this).finish()}static fromBytes(e){return new W(t.PrivateKey.decode(e))}}function Q(e){if(64!==e.bytes.length)throw new Error(`invalid signature length: ${e.bytes.length}`);if(0!==e.recovery&&1!==e.recovery)throw new Error(`invalid recovery bit: ${e.recovery}`)}function Z(e,t){return e.recovery===t.recovery&&X(e.bytes,t.bytes)}function ee(e,t){const s=p.recoverPublicKey(e,t.bytes,t.recovery);return s?new ie({secp256k1Uncompressed:{bytes:s},createdNs:l.fromNumber(0)}):void 0}class te{constructor(e){if(e.ecdsaCompact)Q(e.ecdsaCompact),this.ecdsaCompact=e.ecdsaCompact;else{if(!e.walletEcdsaCompact)throw new Error("invalid signature");Q(e.walletEcdsaCompact),this.walletEcdsaCompact=e.walletEcdsaCompact}}async signerKey(e){return this.ecdsaCompact?Y.signerKey(e,this.ecdsaCompact):this.walletEcdsaCompact?ne.signerKey(e,this.walletEcdsaCompact):void 0}getPublicKey(e){let t;if(this.ecdsaCompact)t=p.recoverPublicKey(e,this.ecdsaCompact.bytes,this.ecdsaCompact.recovery);else{if(!this.walletEcdsaCompact)throw new Error("invalid v1 signature");t=p.recoverPublicKey(e,this.walletEcdsaCompact.bytes,this.walletEcdsaCompact.recovery)}return t?new ae({secp256k1Uncompressed:{bytes:t},timestamp:l.fromNumber(0)}):void 0}equals(e){return this.ecdsaCompact&&e.ecdsaCompact?Z(this.ecdsaCompact,e.ecdsaCompact):!(!this.walletEcdsaCompact||!e.walletEcdsaCompact)&&Z(this.walletEcdsaCompact,e.walletEcdsaCompact)}toBytes(){return s.Signature.encode(this).finish()}static fromBytes(e){return new te(s.Signature.decode(e))}}var se;!function(e){e[e.INBOX_KEY=0]="INBOX_KEY",e[e.SEND_KEY=1]="SEND_KEY"}(se||(se={}));class ne{constructor(e){this.wallet=e}static identitySigRequestText(e){return`XMTP : Create Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}static signerKey(e,t){return ee(v(b(this.identitySigRequestText(e.bytesToSign()))),t)}async signKey(e){const t=e.toBytes(),s=await this.wallet.signMessage(ne.identitySigRequestText(t)),{bytes:n,recovery:r}=J(s),i=new te({walletEcdsaCompact:{bytes:n,recovery:r}});return new oe({keyBytes:t,signature:i})}}const re=new l(10**9).mul(10**9);class ie{constructor(e){if(!e?.secp256k1Uncompressed)throw new Error("invalid public key");!function(e){if(65!==e.bytes.length)throw new Error(`invalid public key length: ${e.bytes.length}`);if(4!==e.bytes[0])throw new Error(`unrecognized public key prefix: ${e.bytes[0]}`)}(e.secp256k1Uncompressed),this.secp256k1Uncompressed=e.secp256k1Uncompressed,this.createdNs=e.createdNs.toUnsigned()}generated(){return new Date(this.timestamp.toNumber())}isFromLegacyKey(){return this.createdNs.lessThan(re)}get timestamp(){return(this.isFromLegacyKey()?this.createdNs:this.createdNs.div(1e6)).toUnsigned()}verify(e,t){return!!e.ecdsaCompact&&p.verify(e.ecdsaCompact.bytes,t,this.secp256k1Uncompressed.bytes)}async verifyKey(e){if(!e.signature)return!1;const t=await _(e.bytesToSign());return this.verify(e.signature,t)}equals(e){return X(this.secp256k1Uncompressed.bytes,e.secp256k1Uncompressed.bytes)}getEthereumAddress(){return function(e){const t=w(e.slice(1)),s=f(t),n=s.substring(s.length-40);return m(`0x${n}`)}(this.secp256k1Uncompressed.bytes)}toBytes(){return n.UnsignedPublicKey.encode(this).finish()}static fromBytes(e){return new ie(n.UnsignedPublicKey.decode(e))}}class oe extends ie{constructor(e){if(!e.keyBytes)throw new Error("missing key bytes");if(super(n.UnsignedPublicKey.decode(e.keyBytes)),this.keyBytes=e.keyBytes,!e.signature)throw new Error("missing key signature");this.signature=new te(e.signature)}get unsignedKey(){return new ie({createdNs:this.createdNs,secp256k1Uncompressed:this.secp256k1Uncompressed})}signerKey(){return this.signature.signerKey(this)}async walletSignatureAddress(){if(!this.signature.walletEcdsaCompact)throw new Error("key was not signed by a wallet");const e=await this.signerKey();if(!e)throw new Error("key signature not valid");return e.getEthereumAddress()}equals(e){return this.unsignedKey.equals(e.unsignedKey)&&this.signature.equals(e.signature)}bytesToSign(){return this.keyBytes}toBytes(){return n.SignedPublicKey.encode(this).finish()}static fromBytes(e){return new oe(n.SignedPublicKey.decode(e))}toLegacyKey(){if(!this.isFromLegacyKey())throw new Error("cannot be converted to legacy key");let e=this.signature;return e.walletEcdsaCompact&&(e=new te({ecdsaCompact:e.walletEcdsaCompact})),new ae({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed,signature:e})}static fromLegacyKey(e,t){if(!e.signature)throw new Error("key is not signed");let s=e.signature;return t&&(s=new te({walletEcdsaCompact:s.ecdsaCompact})),new oe({keyBytes:e.bytesToSign(),signature:s})}}class ae extends ie{constructor(e){super({createdNs:e.timestamp.mul(1e6),secp256k1Uncompressed:e.secp256k1Uncompressed}),e.signature&&(!e.signature.ecdsaCompact&&e.signature.walletEcdsaCompact?this.signature=new te({ecdsaCompact:{bytes:e.signature.walletEcdsaCompact.bytes,recovery:e.signature.walletEcdsaCompact.recovery}}):this.signature=new te(e.signature))}get timestamp(){return this.createdNs.div(1e6)}bytesToSign(){return n.PublicKey.encode({timestamp:this.timestamp,secp256k1Uncompressed:this.secp256k1Uncompressed}).finish()}async signWithWallet(e){const t=await e.signMessage(ne.identitySigRequestText(this.bytesToSign())),{bytes:s,recovery:n}=J(t);this.signature=new te({ecdsaCompact:{bytes:s,recovery:n}})}walletSignatureAddress(){if(!this.signature)throw new Error("key is not signed");const e=v(b(ne.identitySigRequestText(this.bytesToSign()))),t=this.signature.getPublicKey(e);if(!t)throw new Error("key signature is malformed");return t.getEthereumAddress()}toBytes(){return n.PublicKey.encode(this).finish()}static fromBytes(e){return new ae(n.PublicKey.decode(e))}}class ce{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new oe(e.identityKey),this.preKey=new oe(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}toBytes(){return n.SignedPublicKeyBundle.encode(this).finish()}isFromLegacyBundle(){return this.identityKey.isFromLegacyKey()&&this.preKey.isFromLegacyKey()}toLegacyBundle(){return new de({identityKey:this.identityKey.toLegacyKey(),preKey:this.preKey.toLegacyKey()})}static fromBytes(e){const t=n.SignedPublicKeyBundle.decode(e);return new ce(t)}static fromLegacyBundle(e){return new ce({identityKey:oe.fromLegacyKey(e.identityKey,!0),preKey:oe.fromLegacyKey(e.preKey)})}}class de{constructor(e){if(!e.identityKey)throw new Error("missing identity key");if(!e.preKey)throw new Error("missing pre-key");this.identityKey=new ae(e.identityKey),this.preKey=new ae(e.preKey)}equals(e){return this.identityKey.equals(e.identityKey)&&this.preKey.equals(e.preKey)}walletSignatureAddress(){return this.identityKey.walletSignatureAddress()}toBytes(){return n.PublicKeyBundle.encode(this).finish()}static fromBytes(e){const t=n.PublicKeyBundle.decode(e);return new de(t)}}class he{constructor(e,t){this.messageEnvelope=e,this.onSend=t}async messageID(){if(!this.messageEnvelope.message)throw new Error("no envelope message");return j(await _(this.messageEnvelope.message))}async send(){return this.onSend()}}class ye{constructor(e,t,s,n,r){this.messages=[],this.resolvers=[],this.topics=t,this.client=e,this.callback=this.newMessageCallback(s,n),this.onConnectionLost=r}newMessageCallback(e,t){return async s=>{if(s.message)try{const n=await e(s);if(!n)return;if(t){const e=t(n);e&&this.resubscribeToTopics(e)}const r=this.resolvers.pop();r?r({value:n}):this.messages.unshift(n)}catch(e){console.warn(e)}}}async start(){if(!this.callback)throw new Error("Missing callback for stream");this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}static async create(e,t,s,n,r){const i=new ye(e,t,s,n,r);return await i.start(),i}[Symbol.asyncIterator](){return this}async return(){return this.subscriptionManager&&await this.subscriptionManager.unsubscribe(),this.callback?(this.callback=void 0,this.resolvers.forEach((e=>e({value:void 0,done:!0}))),{value:void 0,done:!0}):{value:void 0,done:!0}}next(){const e=this.messages.pop();return e?Promise.resolve({value:e}):this.callback?new Promise((e=>this.resolvers.unshift(e))):Promise.resolve({value:void 0,done:!0})}async resubscribeToTopics(e){if(!this.callback||!this.subscriptionManager)throw new Error("Missing callback for stream");if("function"==typeof this.subscriptionManager?.updateContentTopics)return this.subscriptionManager.updateContentTopics(e);await this.subscriptionManager.unsubscribe(),this.topics=e,this.subscriptionManager=this.client.apiClient.subscribe({contentTopics:this.topics},(async e=>{this.callback&&await(this?.callback(e))}),this.onConnectionLost)}}const{b64Decode:ue,b64Encode:le}=r;function pe(e,t){const s=new Uint8Array(e.length+t.length);return s.set(e),s.set(t,e.length),s}function we(e){return l.fromNumber(e.valueOf()).multiply(1e6)}function fe(e){return new Date(e.divide(1e6).toNumber())}const me=e=>e&&we(e).toString(),ge=e=>{if(e)return fe(l.fromString(e))};class ve extends Error{constructor(e,t){super(t),this.code=e}}const be=e=>{if(e.error)throw new ve(e.error.code,e.error.message);if(!e.result)throw new ve(i.ErrorCode.ERROR_CODE_UNSPECIFIED,"No result from Keystore");if("encrypted"in e.result&&!e.result.encrypted)throw new Error("Missing ciphertext");if("decrypted"in e.result&&!e.result.decrypted)throw new Error("Missing decrypted result");return e.result},Ee=(e,t)=>({requests:e.map((e=>{const s=new de({identityKey:e.header.sender?.identityKey,preKey:e.header.sender?.preKey}),n=t.equals(s);return{payload:e.ciphertext,peerKeys:n?new de({identityKey:e.header.recipient?.identityKey,preKey:e.header.recipient?.preKey}):s,headerBytes:e.headerBytes,isSender:n}}))}),Ke=e=>`/xmtp/0/${e}/proto`,ke=(e,t)=>{const s=[m(e),m(t)];return s.sort(),Ke(`dm-${s.join("-")}`)},Ae=e=>Ke(`m-${e}`),Se=e=>Ke(`contact-${m(e)}`),Te=e=>Ke(`intro-${m(e)}`),Ce=e=>Ke(`invite-${m(e)}`),Pe=e=>Ke(`privatestore-${e}`),Ie=e=>Ke(`userpreferences-${e}`),Be=e=>{const t=/^[\x21-\x7F]+$/,s=e.indexOf("0/");if(-1!==s){const n=e.substring(s+2,e.lastIndexOf("/proto"));return t.test(n)}return!1};class Re{constructor(e,t,s){this.conversationVersion="v1",this.context=void 0,this.peerAddress=m(t),this.client=e,this.createdAt=s}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get topic(){return ke(this.peerAddress,this.client.address)}get ephemeralTopic(){return ke(this.peerAddress,this.client.address).replace("/xmtp/0/dm-","/xmtp/0/dmE-")}async messages(e){const t=ke(this.peerAddress,this.client.address),s=await this.client.listEnvelopes(t,this.processEnvelope.bind(this),e);return this.decryptBatch(s,t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],e.contentTopic,!0);if(!s.length)throw new Error("No results");return s[0]}async prepareMessage(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof de||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Te(this.peerAddress),Te(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const{payload:i}=await this.client.encodeContent(e,t),o=await this.createMessage(i,n,t?.timestamp),a=o.toBytes(),c={contentTopic:r,message:a,timestampNs:me(o.sent)};return new he(c,(async()=>(await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a,timestamp:o.sent})))),Ve.fromV1Message(o,e,t?.contentType||K,i,r,this))))}streamMessages(e){return ye.create(this.client,[this.topic],(async e=>this.decodeMessage(e)),void 0,e)}async processEnvelope({message:e,contentTopic:t}){if(!e||!e.length)throw new Error("empty envelope");const s=await Me.fromBytes(e),{senderAddress:n,recipientAddress:r}=s;if(!n||!r||!t||ke(n,r)!==this.topic)throw new Error("Headers do not match intended recipient");return s}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){let s,n=await this.client.getUserContact(this.peerAddress);if(!n)throw new Error(`recipient ${this.peerAddress} is not registered`);n instanceof de||(n=n.toLegacyBundle());const r=t?.ephemeral?this.ephemeralTopic:this.topic;this.client.contacts.addresses.has(this.peerAddress)?s=[r]:(s=[Te(this.peerAddress),Te(this.client.address),r],this.client.contacts.addresses.add(this.peerAddress));const i=t?.contentType||K,{payload:o}=await this.client.encodeContent(e,t),a=await this.createMessage(o,n,t?.timestamp);return await this.client.publishEnvelopes(s.map((e=>({contentTopic:e,message:a.toBytes(),timestamp:a.sent})))),"unknown"===this.consentState&&await this.allow(),Ve.fromV1Message(a,e,i,o,r,this)}async decryptBatch(e,t,s=!1){const n=(await this.client.keystore.decryptV1(Ee(e,this.client.publicKeyBundle))).responses,r=[];for(let i=0;i<n.length;i++){const o=n[i],a=e[i];try{const{decrypted:e}=be(o);r.push(await this.buildDecodedMessage(a,e,t))}catch(e){if(s)throw e;console.warn("Error decoding content",e)}}return r}async buildDecodedMessage(e,t,s){const{content:n,contentType:r,error:i,contentFallback:o}=await this.client.decodeContent(t);return Ve.fromV1Message(e,n,r,t,s,this,i,o)}async createMessage(e,t,s){return s=s||new Date,Me.encode(this.client.keystore,e,this.client.publicKeyBundle,t,s)}}class Ne{constructor(e,t,s,n,r,i){this.conversationVersion="v2",this.topic=t,this.createdAt=n,this.context=r,this.client=e,this.peerAddress=s,this.consentProof=i}get clientAddress(){return this.client.address}async allow(){await this.client.contacts.allow([this.peerAddress])}async deny(){await this.client.contacts.deny([this.peerAddress])}get isAllowed(){return this.client.contacts.isAllowed(this.peerAddress)}get isDenied(){return this.client.contacts.isDenied(this.peerAddress)}get consentState(){return this.client.contacts.consentState(this.peerAddress)}get consentProofPayload(){return this.consentProof}async messages(e){const t=await this.client.listEnvelopes(this.topic,this.processEnvelope.bind(this),e);return this.decryptBatch(t,!1)}messagesPaginated(e){return this.client.listEnvelopesPaginated(this.topic,this.decodeMessage.bind(this),e)}get ephemeralTopic(){return this.topic.replace("/xmtp/0/m","/xmtp/0/mE")}streamEphemeral(e){return ye.create(this.client,[this.ephemeralTopic],this.decodeMessage.bind(this),void 0,e)}streamMessages(e){return ye.create(this.client,[this.topic],this.decodeMessage.bind(this),void 0,e)}async send(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=t?.ephemeral?this.ephemeralTopic:this.topic;await this.client.publishEnvelopes([{contentTopic:i,message:r.toBytes(),timestamp:r.sent}]);const o=t?.contentType||K;return"unknown"===this.consentState&&await this.allow(),Ve.fromV2Message(r,e,o,i,s,this,this.client.address)}async createMessage(e,t,s){const n={topic:this.topic,createdNs:we(s||new Date)},r=o.MessageHeaderV2.encode(n).finish(),i=await _(pe(r,e)),c={payload:e,sender:this.client.signedPublicKeyBundle,signature:await this.client.keystore.signDigest({digest:i,prekeyIndex:0,identityKey:void 0})},d=a.SignedContent.encode(c).finish(),{encrypted:h,senderHmac:y}=await this.encryptMessage(d,r),u={v1:void 0,v2:{headerBytes:r,ciphertext:h,senderHmac:y,shouldPush:t}},l=o.Message.encode(u).finish();return _e.create(u,n,l,y,t)}async decryptBatch(e,t=!1){const s=(await this.client.keystore.decryptV2(this.buildDecryptRequest(e))).responses,n=[];for(let r=0;r<s.length;r++){const i=s[r],o=e[r];try{const{decrypted:e}=be(i);n.push(await this.buildDecodedMessage(o,e))}catch(e){if(t)throw e;console.warn("Error decoding content",e)}}return n}buildDecryptRequest(e){return{requests:e.map((e=>({payload:e.ciphertext,headerBytes:e.headerBytes,contentTopic:this.topic})))}}async encryptMessage(e,t){const{responses:s}=await this.client.keystore.encryptV2({requests:[{payload:e,headerBytes:t,contentTopic:this.topic}]});if(1!==s.length)throw new Error("Invalid response length");const{encrypted:n,senderHmac:r}=be(s[0]);return{encrypted:n,senderHmac:r}}async buildDecodedMessage(e,t){const s=a.SignedContent.decode(t);if(!s.sender?.identityKey||!s.sender?.preKey||!s.signature)throw new Error("incomplete signed content");await async function(e){const t=e.sender?.preKey;if(!t||!t.signature||!t.keyBytes)throw new Error("missing pre-key or pre-key signature");const s=e.sender?.identityKey;if(!s)throw new Error("missing identity key in bundle");if(!await new oe(s).verifyKey(new oe(t)))throw new Error("pre key not signed by identity key")}(s);const n=await _(pe(e.headerBytes,s.payload));if(!new oe(s.sender?.preKey).verify(new te(s.signature),n))throw new Error("invalid signature");const r=await new ce(s.sender).walletSignatureAddress(),{content:i,contentType:o,error:c,contentFallback:d}=await this.client.decodeContent(s.payload);return Ve.fromV2Message(e,i,o,this.topic,s.payload,this,r,c,d)}async prepareMessage(e,t){const{payload:s,shouldPush:n}=await this.client.encodeContent(e,t),r=await this.createMessage(s,n,t?.timestamp),i=r.toBytes(),o=t?.ephemeral?this.ephemeralTopic:this.topic,a={contentTopic:o,message:i,timestampNs:me(r.sent)};return new he(a,(async()=>(await this.client.publishEnvelopes([{contentTopic:o,message:i,timestamp:r.sent}]),Ve.fromV2Message(r,e,t?.contentType||K,o,s,this,this.client.address))))}async processEnvelope(e){if(!e.message||!e.contentTopic)throw new Error("empty envelope");const t=o.Message.decode(e.message);if(!t.v2)throw new Error("unknown message version");const s=o.MessageHeaderV2.decode(t.v2.headerBytes);if(s.topic!==this.topic)throw new Error("topic mismatch");return _e.create(t,s,e.message,t.v2.senderHmac,t.v2.shouldPush)}async decodeMessage(e){if(!e.contentTopic)throw new Error("Missing content topic");const t=await this.processEnvelope(e),s=await this.decryptBatch([t],!0);if(!s.length)throw new Error("No results");return s[0]}}const De=e=>{if(e.v1?.ciphertext)return[e.v1.headerBytes,new N(e.v1.ciphertext)];if(e.v2?.ciphertext)return[e.v2.headerBytes,new N(e.v2.ciphertext)];throw new Error("unknown message version")};class xe{constructor(e,t,s){[this.headerBytes,this.ciphertext]=De(s),this.id=e,this.bytes=t}toBytes(){return this.bytes}}class Me extends xe{constructor(e,t,s,n,r){super(e,t,s),this.conversation=void 0,this.senderAddress=r,this.header=n}static async create(e,t,s){if(!t.sender)throw new Error("missing message sender");const n=new de(t.sender).walletSignatureAddress(),r=j(await _(s));return new Me(r,s,e,t,n)}get sent(){return new Date(this.header.timestamp.toNumber())}get recipientAddress(){if(this.header?.recipient?.identityKey)return new ae(this.header.recipient.identityKey).walletSignatureAddress()}async decrypt(e,t){const s=(await e.decryptV1(Ee([this],t))).responses;if(!s.length)throw new Error("No response from Keystore");const{decrypted:n}=be(s[0]);return n}static fromBytes(e){const t=o.Message.decode(e),[s]=De(t),n=o.MessageHeaderV1.decode(s);if(!n)throw new Error("missing message header");if(!n.sender)throw new Error("missing message sender");if(!n.sender.identityKey)throw new Error("missing message sender identity key");if(!n.sender.preKey)throw new Error("missing message sender pre-key");if(!n.recipient)throw new Error("missing message recipient");if(!n.recipient.identityKey)throw new Error("missing message recipient identity-key");if(!n.recipient.preKey)throw new Error("missing message recipient pre-key");return Me.create(t,n,e)}static async encode(e,t,s,n,r){const i={sender:s,recipient:n,timestamp:l.fromNumber(r.getTime())},a=o.MessageHeaderV1.encode(i).finish(),c=await e.encryptV1({requests:[{recipient:n,headerBytes:a,payload:t}]});if(!c.responses.length)throw new Error("No response from Keystore");const{encrypted:d}=be(c.responses[0]),h={v1:{headerBytes:a,ciphertext:d},v2:void 0},y=o.Message.encode(h).finish();return Me.create(h,i,y)}}class _e extends xe{constructor(e,t,s,n,r,i){super(e,t,s),this.header=n,this.senderHmac=r,this.shouldPush=i}static async create(e,t,s,n,r){const i=j(await _(s));return new _e(i,s,e,t,n,r)}get sent(){return fe(this.header.createdNs)}}class Ve{constructor({id:e,messageVersion:t,senderAddress:s,recipientAddress:n,conversation:r,contentBytes:i,contentType:o,contentTopic:a,content:c,sent:d,error:h,contentFallback:y}){this.id=e,this.messageVersion=t,this.senderAddress=s,this.recipientAddress=n,this.conversation=r,this.contentType=o,this.sent=d,this.error=h,this.content=c,this.contentTopic=a,this.contentBytes=i,this.contentFallback=y}toBytes(){return o.DecodedMessage.encode({...this,conversation:{topic:this.conversation.topic,context:this.conversation.context??void 0,createdNs:we(this.conversation.createdAt),peerAddress:this.conversation.peerAddress,consentProofPayload:this.conversation.consentProof??void 0},sentNs:we(this.sent)}).finish()}static async fromBytes(e,t){const s=o.DecodedMessage.decode(e),n=s.messageVersion;if("v1"!==n&&"v2"!==n)throw new Error("Invalid message version");if(!s.conversation)throw new Error("No conversation reference found");const{content:r,contentType:i,error:a,contentFallback:c}=await t.decodeContent(s.contentBytes);return new Ve({...s,content:r,contentType:i,error:a,messageVersion:n,sent:fe(s.sentNs),conversation:Ue(s.conversation,t,n),contentFallback:c})}static fromV1Message(e,t,s,n,r,i,o,a){const{id:c,senderAddress:d,recipientAddress:h,sent:y}=e;if(!d)throw new Error("Sender address is required");return new Ve({id:c,messageVersion:"v1",senderAddress:d,recipientAddress:h,sent:y,content:t,contentBytes:n,contentType:s,contentTopic:r,conversation:i,error:o,contentFallback:a})}static fromV2Message(e,t,s,n,r,i,o,a,c){const{id:d,sent:h}=e;return new Ve({id:d,messageVersion:"v2",senderAddress:o,sent:h,content:t,contentBytes:r,contentType:s,contentTopic:n,conversation:i,error:a,contentFallback:c})}}function Ue(e,t,s){if("v1"===s)return new Re(t,e.peerAddress,fe(e.createdNs));if("v2"===s)return new Ne(t,e.topic,e.peerAddress,fe(e.createdNs),e.context,e.consentProofPayload);throw new Error(`Unknown conversation version ${s}`)}function Le(e,t){return t.decodeContent(e)}class qe extends Error{constructor(e){super(`no pre-key matches: ${j(e.secp256k1Uncompressed.bytes)}`)}}class Oe{constructor(e){if(this.version=2,!e.identityKey)throw new Error("missing identity key");this.identityKey=new Y(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new Y(e)))}static async generate(e){const t=await Y.generate(new ne(e)),s=new Oe({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new qe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=await Y.generate(this.identityKey);this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new ce({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(n.length+r.length+o.length);return a.set(n,0),a.set(r,n.length),a.set(o,n.length+r.length),a}encode(){return t.PrivateKeyBundle.encode({v1:void 0,v2:this}).finish()}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}equals(e){if(this.preKeys.length!==e.preKeys.length)return!1;for(let t=0;t<this.preKeys.length;t++)if(!this.preKeys[t].equals(e.preKeys[t]))return!1;return this.identityKey.equals(e.identityKey)}static fromLegacyBundle(e){return new Oe({identityKey:Y.fromLegacyKey(e.identityKey,!0),preKeys:e.preKeys.map((e=>Y.fromLegacyKey(e)))})}}class Ge{constructor(e){if(this.version=1,!e.identityKey)throw new Error("missing identity key");this.identityKey=new W(e.identityKey),this.preKeys=(e.preKeys||[]).map((e=>new W(e)))}static async generate(e){const t=W.generate();e&&await t.publicKey.signWithWallet(e);const s=new Ge({identityKey:t,preKeys:[]});return await s.addPreKey(),s}getCurrentPreKey(){return this.preKeys[0]}findPreKey(e){const t=this.preKeys.find((t=>t.matches(e)));if(!t)throw new qe(e);return t}async addPreKey(){this._publicKeyBundle=void 0;const e=W.generate();await this.identityKey.signKey(e.publicKey),this.preKeys.unshift(e)}getPublicKeyBundle(){return this._publicKeyBundle||(this._publicKeyBundle=new de({identityKey:this.identityKey.publicKey,preKey:this.getCurrentPreKey().publicKey})),this._publicKeyBundle}validatePublicKeys(){return!!this.identityKey.validatePublicKey()&&this.preKeys.every((e=>e.validatePublicKey()))}async sharedSecret(e,t,s){if(!e.identityKey||!e.preKey)throw new Error("invalid peer key bundle");if(!await e.identityKey.verifyKey(e.preKey))throw new Error("peer preKey signature invalid");if(!this.identityKey)throw new Error("missing identity key");let n,r,i;s?(i=this.findPreKey(t),n=i.sharedSecret(e.identityKey),r=this.identityKey.sharedSecret(e.preKey)):(i=this.findPreKey(t),n=this.identityKey.sharedSecret(e.preKey),r=i.sharedSecret(e.identityKey));const o=i.sharedSecret(e.preKey),a=new Uint8Array(n.length+r.length+o.length);return a.set(n,0),a.set(r,n.length),a.set(o,n.length+r.length),a}encode(){return t.PrivateKeyBundle.encode({v1:this,v2:void 0}).finish()}}function He(e){const s=t.PrivateKeyBundle.decode(e);if(s.v1)return new Ge(s.v1);if(s.v2)return new Oe(s.v2);throw new Error("unknown private key bundle version")}class Fe{constructor({walletAddr:e,createdNs:t}){this.walletAddr=e,this.createdNs=t}static create(e,t){return t=t||new Date,new Fe({walletAddr:e,createdNs:we(t)})}static fromBytes(e){const t=c.AuthData.decode(e);return new Fe(t)}toBytes(){return c.AuthData.encode(this).finish()}}class $e{constructor({identityKey:e,authDataBytes:t,authDataSignature:s}){if(!e)throw new Error("Missing identity key in token");if(!s)throw new Error("Missing authDataSignature in token");this.identityKey=e,this.authDataBytes=t,this.authDataSignature=s}get authData(){return this._authData||(this._authData=Fe.fromBytes(this.authDataBytes)),this._authData}get ageMs(){return(new Date).valueOf()-this.authData.createdNs.div(1e6).toNumber()}toBytes(){return c.Token.encode(this).finish()}static fromBytes(e){return new $e(c.Token.decode(e))}toBase64(){return Buffer.from(this.toBytes()).toString("base64")}}class je{constructor(e){this.keystore=e}async createToken(e){return(e=>e instanceof $e?e:new $e(e))(await this.keystore.createAuthToken({timestampNs:e?we(e):void 0}))}}const Xe=e=>new Promise((t=>setTimeout(t,e))),Je=e=>!!e;async function ze(e,t,s,n,r=Je,i=1){const o="number"==typeof i?i:1;try{return await e(...t)}catch(i){if(!r(i)||o>s)throw i;return await Xe(n),ze(e,t,s,n,r,o+1)}}async function*Ye(e,t){for await(const s of e){const e=await Promise.allSettled(s.map(t)),n=[];for(const t of e)"fulfilled"===t.status?n.push(t.value):console.warn("Failed to process envelope due to reason: ",t.reason);yield n}}class We{constructor(e,t=3590){this.authenticator=e,this.maxAgeMs=1e3*t}async getToken(){return(!this.token||this.token.ageMs>this.maxAgeMs)&&await this.refresh(),this.token.toBase64()}async refresh(){this.token=await this.authenticator.createToken()}}const{MessageApi:Qe,SortDirection:Ze}=d,et={local:"http://localhost:5555",dev:"https://dev.xmtp.network",production:"https://production.xmtp.network"};var tt;!function(e){e[e.OK=0]="OK",e[e.CANCELLED=1]="CANCELLED",e[e.UNKNOWN=2]="UNKNOWN",e[e.INVALID_ARGUMENT=3]="INVALID_ARGUMENT",e[e.DEADLINE_EXCEEDED=4]="DEADLINE_EXCEEDED",e[e.NOT_FOUND=5]="NOT_FOUND",e[e.ALREADY_EXISTS=6]="ALREADY_EXISTS",e[e.PERMISSION_DENIED=7]="PERMISSION_DENIED",e[e.RESOURCE_EXHAUSTED=8]="RESOURCE_EXHAUSTED",e[e.FAILED_PRECONDITION=9]="FAILED_PRECONDITION",e[e.ABORTED=10]="ABORTED",e[e.OUT_OF_RANGE=11]="OUT_OF_RANGE",e[e.UNIMPLEMENTED=12]="UNIMPLEMENTED",e[e.INTERNAL=13]="INTERNAL",e[e.UNAVAILABLE=14]="UNAVAILABLE",e[e.DATA_LOSS=15]="DATA_LOSS",e[e.UNAUTHENTICATED=16]="UNAUTHENTICATED"}(tt||(tt={}));class st extends Error{constructor(e,t){super(e),this.code=t}static fromObject(e){return new st(e.message,e.code)}}const nt=e=>!!e&&!("AbortError"!==e.name&&!e.message.includes("aborted")),rt=e=>!(e=>!(!e||!("code"in e)||16!==e.code))(e),it=e=>e.message&&e.message.length?("string"==typeof e.message&&(e.message=ue(e.message)),e):e;class ot{constructor(e,t){this.pathPrefix=e,this.maxRetries=t?.maxRetries||5,this.appVersion=t?.appVersion,this.version="xmtp-js/12.1.0",e===et.dev&&console.info("\nXX    XX MM    MM TTTTTT PPPPPP   DDDDD   EEEEEEE VV     VV \n XX  XX  MMM  MMM   TT   PP   PP  DD  DD  EE      VV     VV \n  XXXX   MM MM MM   TT   PPPPPP   DD   DD EEEEE    VV   VV  \n XX  XX  MM    MM   TT   PP       DD   DD EE        VV VV   \nXX    XX MM    MM   TT   PP       DDDDDD  EEEEEEE    VVV    \n\nConnected to the XMTP 'dev' network. Use 'production' for production messages.\nhttps://github.com/xmtp/xmtp-js#xmtp-production-and-dev-network-environments\n")}async _query(e){try{return await ze(Qe.Query,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}catch(e){throw st.fromObject(e)}}_batchQuery(e){return ze(Qe.BatchQuery,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:this.headers()}],this.maxRetries,100)}async _publish(e,t=0){const s=await this.getToken(),n=this.headers();n.set("Authorization",`Bearer ${s}`);try{return await ze(Qe.Publish,[e,{pathPrefix:this.pathPrefix,mode:"cors",headers:n}],this.maxRetries,100,rt)}catch(s){if(rt(s)||t>=1)throw st.fromObject(s);return await(this.authCache?.refresh()),this._publish(e,t+1)}}_subscribe(e,t,s){const n=new AbortController;return(async()=>{for(;;){const r=(new Date).getTime();try{if(await Qe.Subscribe(e,t,{pathPrefix:this.pathPrefix,signal:n.signal,mode:"cors",headers:this.headers()}),n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Xe(1e3),s?.()}catch(e){if(nt(e)||n.signal.aborted)return;console.info("Stream connection closed. Resubscribing"),(new Date).getTime()-r<1e3&&await Xe(1e3),s?.()}}})(),{unsubscribe:async()=>{n?.abort()}}}async query(e,{direction:t=Ze.SORT_DIRECTION_ASCENDING,limit:s}){const n=[];for await(const r of this.queryIteratePages(e,{direction:t,pageSize:s&&s<100?s:100}))for(const e of r)if(n.push(e),s&&n.length===s)return n;return n}async*queryIterator(e,t){for await(const s of this.queryIteratePages(e,t))for(const e of s)yield e}async*queryIteratePages({contentTopic:e,startTime:t,endTime:s},{direction:n,pageSize:r=10}){if(!e||!e.length)throw new Error("Must specify content topics");const i=me(t),o=me(s);let a;for(;;){const t={limit:r,direction:n,cursor:a},s=await this._query({contentTopics:[e],startTimeNs:i,endTimeNs:o,pagingInfo:t});if(!s.envelopes?.length)return;if(yield s.envelopes.map(it),!s.pagingInfo?.cursor)return;a=s.pagingInfo?.cursor}}async batchQuery(e){const t=[];for(let s=0;s<e.length;s+=50){const n=e.slice(s,s+50),r=[];for(const e of n)r.push({contentTopics:[e.contentTopic],startTimeNs:me(e.startTime),endTimeNs:me(e.endTime),pagingInfo:{limit:e.pageSize||10,direction:e.direction||Ze.SORT_DIRECTION_ASCENDING}});const i={requests:r};t.push(i)}const s=await Promise.all(t.map((async e=>this._batchQuery(e)))),n=[];for(const e of s){if(!e.responses)throw new Error("BatchQueryResponse missing responses");for(const t of e.responses)t.envelopes?n.push(t.envelopes.map(it)):n.push([])}return n}async publish(e){const t=[];for(const{contentTopic:s,message:n,timestamp:r}of e){if(!s.length)throw new Error("Content topic cannot be empty string");if(!n.length)throw new Error("0 length messages not allowed");const e=r||new Date;t.push({contentTopic:s,timestampNs:me(e),message:Uint8Array.from(n)})}return this._publish({envelopes:t})}subscribe(e,t,s){if(!e.contentTopics.length)throw new Error("Must provide list of contentTopics to subscribe to");return this._subscribe(e,(e=>t(it(e))),s)}getToken(){if(!this.authCache)throw new Error("AuthCache is not set on API Client");return this.authCache.getToken()}setAuthenticator(e,t){this.authCache=new We(e,t)}headers(){const e=new Headers;return e.set("X-Client-Version",this.version),this.appVersion&&e.set("X-App-Version",this.appVersion),e}}class at{constructor(e,t){this.disableOffset=!1,this.jobType=e,this.mutex=new S,this.keystore=t}get protoJobType(){return function(e){const t={v1:i.JobType.JOB_TYPE_REFRESH_V1,v2:i.JobType.JOB_TYPE_REFRESH_V2,"user-preferences":i.JobType.JOB_TYPE_REFRESH_PPPP}[e];if(!t)throw new Error(`unknown job type: ${e}`);return t}(this.jobType)}async run(e){return this.mutex.runExclusive((async()=>{const t=await this.getLastRunTime(),s=new Date,n=await e(t?this.disableOffset?t:new Date(t.getTime()-1e4):void 0);return await this.setLastRunTime(s),n}))}async resetLastRunTime(){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:we(new Date(0))})}async getLastRunTime(){const{lastRunNs:e}=await this.keystore.getRefreshJob(i.GetRefreshJobRequest.fromPartial({jobType:this.protoJobType}));if(!e.equals(l.fromNumber(0)))return fe(e)}async setLastRunTime(e){await this.keystore.setRefreshJob({jobType:this.protoJobType,lastRunNs:we(e)})}}const ct=e=>Boolean(e.recipientAddress&&e.senderAddress);class dt{constructor(e){this.client=e,this.v1JobRunner=new at("v1",e.keystore),this.v2JobRunner=new at("v2",e.keystore)}async list(){const[e,t]=await Promise.all([this.listV1Conversations(),this.listV2Conversations()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listFromCache(){const[e,t]=await Promise.all([this.getV1ConversationsFromKeystore(),this.getV2ConversationsFromKeystore()]),s=e.concat(t);return s.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),s}async listV1Conversations(){return this.v1JobRunner.run((async e=>{const t=await this.getIntroductionPeers({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return await this.client.keystore.saveV1Conversations({conversations:Array.from(t).map((([e,t])=>({peerAddress:e,createdNs:we(t),topic:ke(e,this.client.address),context:void 0,consentProofPayload:void 0}))).filter((e=>Be(e.topic)))}),(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}))}async listV2Conversations(){return this.v2JobRunner.run((async e=>{const t=await this.getV2ConversationsFromKeystore(),s=await this.updateV2Conversations(e),n=new Set(t.map((e=>e.topic)));for(const e of s)n.has(e.topic)||(t.push(e),n.add(e.topic));return t.sort(((e,t)=>e.createdAt.getTime()-t.createdAt.getTime())),t}))}async getV2ConversationsFromKeystore(){return(await this.client.keystore.getV2Conversations()).conversations.map(this.conversationReferenceToV2.bind(this))}async getV1ConversationsFromKeystore(){return(await this.client.keystore.getV1Conversations()).conversations.map(this.conversationReferenceToV1.bind(this))}async updateV2Conversations(e){const t=await this.client.listInvitations({startTime:e,direction:Ze.SORT_DIRECTION_ASCENDING});return this.decodeInvites(t)}async decodeInvites(e,t=!1){const{responses:s}=await this.client.keystore.saveInvites({requests:e.map((e=>({payload:e.message,timestampNs:l.fromString(e.timestampNs),contentTopic:e.contentTopic}))).filter((e=>Be(e.contentTopic)))}),n=[];for(const e of s)try{n.push(this.saveInviteResponseToConversation(e))}catch(e){if(console.warn("Error saving invite response to conversation: ",e),t)throw e}return n}saveInviteResponseToConversation({result:e,error:t}){if(t||!e||!e.conversation)throw new Error(`Error from keystore: ${t?.code} ${t?.message}}`);return this.conversationReferenceToV2(e.conversation)}conversationReferenceToV2(e){return new Ne(this.client,e.topic,e.peerAddress,fe(e.createdNs),e.context,e.consentProofPayload)}conversationReferenceToV1(e){return new Re(this.client,e.peerAddress,fe(e.createdNs))}async stream(e){const t=new Set,s=Te(this.client.address),n=Ce(this.client.address),r=[s,n];return ye.create(this.client,r,(async e=>{if(e.contentTopic===s){if(!e.message)throw new Error("empty envelope");const s=await Me.fromBytes(e.message),n=this.getPeerAddress(s);if(!(e=>!t.has(e)&&(t.add(e),!0))(n))return;return await s.decrypt(this.client.keystore,this.client.publicKeyBundle),new Re(this.client,n,s.sent)}if(e.contentTopic===n){const t=await this.decodeInvites([e],!0);if(t.length)return t[0]}throw new Error("unrecognized invite topic")}).bind(this),void 0,e)}async streamAllMessages(e){const t=Te(this.client.address),s=Ce(this.client.address),n=new Set([t,s]),r=new Map;for(const e of await this.list())n.add(e.topic),r.set(e.topic,e);const i=(e,t)=>!n.has(e)&&(r.set(e,t),n.add(e),!0),o=await ye.create(this.client,Array.from(n.values()),(async e=>{const n=e.contentTopic;if(!n||!e.message)return null;if(n===t){const t=await Me.fromBytes(e.message);if(!ct(t))return null;const s=this.getPeerAddress(t);return new Re(this.client,s,t.sent).decodeMessage(e)}if(n===s){return(await this.decodeInvites([e],!0))[0]}const i=r.get(n);if(i instanceof Re)return i.decodeMessage(e);if(i instanceof Ne)return i.decodeMessage(e);throw console.log("Unknown topic"),new Error("Unknown topic")}),(e=>{if(e instanceof Ve&&e.contentTopic===t){const t=new Re(this.client,e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress,e.sent);return i(t.topic,t)?Array.from(n.values()):void 0}if(e instanceof Ne){return i(e.topic,e)?Array.from(n.values()):void 0}}),e),a=async function*(){for await(const e of o)if(e instanceof Ve&&(yield e),e instanceof Ne)for(const t of await e.messages())yield t}();return a.return=async()=>(await(o?.return()),{value:void 0,done:!0}),a}async getIntroductionPeers(e){const t=Te(this.client.address),s=await this.client.listEnvelopes(t,(e=>{if(!e.message)throw new Error("empty envelope");return Me.fromBytes(e.message)}),e),n=new Map;for(const e of s){if(!ct(e))continue;const t=this.getPeerAddress(e);if(t){const s=n.get(t);if(!s||s>e.sent)try{await e.decrypt(this.client.keystore,this.client.publicKeyBundle),n.set(t,e.sent)}catch(e){continue}}}return n}async newConversation(e,t,s){const n=s=>{return s.peerAddress.toLowerCase()===e.toLowerCase()&&(n=t,r=s.context??void 0,n?.conversationId===r?.conversationId);var n,r},r=(await this.getV2ConversationsFromKeystore()).find(n);if(r)return r;let i=await this.client.getUserContact(e);if(!i)throw new Error(`Recipient ${e} is not on the XMTP network`);if(e.toLowerCase()===this.client.address.toLowerCase())throw new Error("self messaging not supported");if(i instanceof de&&!t?.conversationId)return new Re(this.client,e,new Date);if(!t?.conversationId){const t=(await this.listV1Conversations()).find((t=>t.peerAddress.toLowerCase()===e.toLowerCase()));if(t){if(!this.client.signedPublicKeyBundle.isFromLegacyBundle())throw new Error("cannot resume pre-existing V1 conversation; client keys not compatible");if(!(i instanceof de||i.isFromLegacyBundle()))throw new Error("cannot resume pre-existing V1 conversation; peer keys not compatible");return t}}return i instanceof de&&(i=ce.fromLegacyBundle(i)),this.v2JobRunner.run((async e=>{const r=(await this.updateV2Conversations(e)).find(n);return r||this.createV2Convo(i,t,s)}))}async createV2Convo(e,t,s){const n=new Date,{payload:r,conversation:i}=await this.client.keystore.createInvite({recipient:e,context:t,createdNs:we(n),consentProof:s});if(!r||!i)throw new Error("Required field not returned from Keystore");const o=await e.walletSignatureAddress();return await this.client.publishEnvelopes([{contentTopic:Ce(o),message:r,timestamp:n},{contentTopic:Ce(this.client.address),message:r,timestamp:n}]),await this.client.contacts.allow([o]),this.conversationReferenceToV2(i)}getPeerAddress(e){return e.recipientAddress?.toLowerCase()===this.client.address.toLowerCase()?e.senderAddress:e.recipientAddress}}class ht{constructor(e){this.storage=e}static create(){if("undefined"==typeof localStorage)throw new Error("Missing LocalStorage. Use ephemeralPersistence instead");return new ht(localStorage)}async getItem(e){const t=this.storage.getItem(e);return null===t?null:Uint8Array.from(Buffer.from(t,"binary"))}async setItem(e,t){this.storage.setItem(e,Buffer.from(t).toString("binary"))}}class yt{constructor(){this.store=new Map}get length(){return this.store.size}clear(){this.store=new Map}getItem(e){return this.validateString(e),this.store.has(e)?String(this.store.get(e)):null}key(e){if(void 0===e)throw new TypeError("Failed to execute 'key' on 'Storage': 1 argument required, but only 0 present.");const t=[...this.store.keys()];return e>=t.length?null:t[e]}removeItem(e){this.validateString(e),this.store.delete(e)}setItem(e,t){this.validateString(e),this.validateString(t),this.store.set(String(e),String(t))}validateString(e){if("string"!=typeof e)throw new TypeError("Key must be a string")}}class ut extends ht{static create(){return new ht(new yt)}}class lt extends Error{}class pt{constructor(e){if(!e.publicKey.signature)throw new Error("Provided public key is not signed");this.identityKey=e}async createToken(e){const t=Fe.create(this.identityKey.publicKey.walletSignatureAddress(),e||new Date).toBytes(),r=f(t),i=await this.identityKey.sign(v(r));return new $e(c.Token.fromPartial({identityKey:n.PublicKey.fromPartial(this.identityKey.publicKey),authDataBytes:t,authDataSignature:s.Signature.fromPartial(i)}))}}const wt=new(0,T.ec)("secp256k1"),ft=D.subtle,mt=Buffer.from("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141","hex"),gt=Buffer.alloc(32,0);function vt(e,t){if(!e)throw new Error(t||"Assertion failed")}function bt(e){return t=e,!(!Buffer.isBuffer(t)||32!==t.length)&&(e.compare(gt)>0&&e.compare(mt)<0);var t}function Et(e){const t=new Uint8Array(e);return D.getRandomValues(t),Buffer.from(t)}async function Kt(e){const t=await ft.digest("SHA-512",e);return Buffer.from(t)}function kt(e){return function(t,s,n){return new Promise((function(r){return ft.importKey("raw",s,{name:"AES-CBC"},!1,[e]).then((function(s){const r={name:"AES-CBC",iv:t};return ft[e](r,s,n)})).then((function(e){r(Buffer.from(new Uint8Array(e)))}))}))}}const At=kt("encrypt"),St=kt("decrypt");async function Tt(e,t){const s=await ft.importKey("raw",e,{name:"HMAC",hash:{name:"SHA-256"}},!1,["sign"]);return Buffer.from(await ft.sign({name:"HMAC",hash:"SHA-256"},s,t))}function Ct(e){return vt(32===e.length,"Bad private key"),vt(bt(e),"Bad private key"),Buffer.from(wt.keyFromPrivate(e).getPublic("array"))}function Pt(e,t){return new Promise((function(s){vt(Buffer.isBuffer(e),"Bad private key"),vt(Buffer.isBuffer(t),"Bad public key"),vt(32===e.length,"Bad private key"),vt(bt(e),"Bad private key"),vt(65===t.length||33===t.length,"Bad public key"),65===t.length&&vt(4===t[0],"Bad public key"),33===t.length&&vt(2===t[0]||3===t[0],"Bad public key");const n=wt.keyFromPrivate(e),r=wt.keyFromPublic(t),i=n.derive(r.getPublic());s(Buffer.from(i.toArray()))}))}async function It(e,t){const s=await Pt(e,t.ephemeralPublicKey),n=await Kt(s),r=n.slice(0,32),i=n.slice(32),o=Buffer.concat([t.iv,t.ephemeralPublicKey,t.ciphertext]);return vt(await async function(e,t,s){return function(e,t){if(e.length!==t.length)return!1;let s=0;for(let n=0;n<e.length;n++)s|=e[n]^t[n];return 0===s}(await Tt(e,t),s)}(i,o,t.mac),"Bad mac"),St(t.iv,r,t.ciphertext)}async function Bt(e,t){await C();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return P(s,n,t)}async function Rt(e,t){await C();const s=e.publicKey.secp256k1Uncompressed.bytes,n=e.secp256k1.bytes;return I(s,n,t)}class Nt{constructor({topic:e,context:t,aes256GcmHkdfSha256:s,consentProof:n}){if(!e||!e.length)throw new Error("Missing topic");if(!s||!s.keyMaterial||!s.keyMaterial.length)throw new Error("Missing key material");this.topic=e,this.context=t,this.aes256GcmHkdfSha256=s,this.consentProof=n}static createRandom(e,t){const s=Ae(Buffer.from(D.getRandomValues(new Uint8Array(32))).toString("base64").replace(/=*$/g,"").replace(/\//g,"-")),n=D.getRandomValues(new Uint8Array(32));return new Nt({topic:s,aes256GcmHkdfSha256:{keyMaterial:n},context:e,consentProof:t})}toBytes(){return h.InvitationV1.encode(this).finish()}static fromBytes(e){return new Nt(h.InvitationV1.decode(e))}}class Dt{constructor({sender:e,recipient:t,createdNs:s}){if(!e)throw new Error("Missing sender");if(!t)throw new Error("Missing recipient");this.sender=new ce(e),this.recipient=new ce(t),this.createdNs=s}toBytes(){return h.SealedInvitationHeaderV1.encode(this).finish()}static fromBytes(e){return new Dt(h.SealedInvitationHeaderV1.decode(e))}}class xt{constructor({headerBytes:e,ciphertext:t}){if(!e||!e.length)throw new Error("Missing header bytes");if(!t)throw new Error("Missing ciphertext");this.headerBytes=e,this.ciphertext=new N(t)}get header(){return this._header||(this._header=Dt.fromBytes(this.headerBytes)),this._header}async getInvitation(e){if(this._invitation)return this._invitation;const t=this.header;let s;s=e.identityKey.matches(this.header.sender.identityKey)?await e.sharedSecret(t.recipient,t.sender.preKey,!1):await e.sharedSecret(t.sender,t.recipient.preKey,!0);const n=await U(this.ciphertext,s,this.headerBytes);return this._invitation=Nt.fromBytes(n),this._invitation}toBytes(){return h.SealedInvitationV1.encode(this).finish()}static fromBytes(e){return new xt(h.SealedInvitationV1.decode(e))}}class Mt{constructor({v1:e}){if(!e)throw new Error("Missing v1 or v2 invitation");this.v1=new xt(e)}toBytes(){return h.SealedInvitation.encode(this).finish()}static fromBytes(e){return new Mt(h.SealedInvitation.decode(e))}static async fromEnvelope(e){if(!e.message||!e.timestampNs)throw new Error("invalid invitation envelope");const t=Mt.fromBytes(e.message),s=l.fromString(e.timestampNs),n=t.v1?.header.createdNs;if(!n||!n.equals(s))throw new Error("envelope and header timestamp mistmatch");return t}static async createV1({sender:e,recipient:t,created:s,invitation:n}){const r=new Dt({sender:e.getPublicKeyBundle(),recipient:t,createdNs:we(s)}).toBytes(),i=await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),o=n.toBytes(),a=await V(o,i,r);return new Mt({v1:{headerBytes:r,ciphertext:a}})}}const _t=(e,t)=>e instanceof ve?e:new ve(t,e.message),Vt=(e,t,s)=>Promise.all(e.map((async e=>{try{return{result:await t(e)}}catch(e){return{error:_t(e,s)}}}))),Ut=e=>e instanceof de?e:new de(e),Lt=(e,t,s)=>{for(const s of t)if(!e[s])throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(s)}`);for(const t of s){const s=e[t];if(!s||!s?.length)throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,`Missing field ${String(t)}`)}return!0},qt=e=>{if(!e?.aes256GcmHkdfSha256?.keyMaterial)throw new ve(i.ErrorCode.ERROR_CODE_INVALID_INPUT,"Missing key material");return e.aes256GcmHkdfSha256.keyMaterial},Ot=({invitation:e,createdNs:t,peerAddress:s})=>({context:e.context,topic:e.topic,peerAddress:s,createdNs:t,consentProofPayload:e.consentProof});class Gt{constructor(e,t,s=new Map){this.persistenceKey=t,this.persistence=e,this.revision=0,this.mutex=new S,this.topicMap=s}get revisionKey(){return this.persistenceKey+"/revision"}static async create(e){const t=new Gt(e,"invitations/v1");return await t.refresh(),t}validate(e){return!!e.topic&&e.topic.length>0&&!!e.invitation}async refresh(){const e=await this.getRevision();if(e>this.revision)for(const[e,t]of await this.loadFromPersistence())this.topicMap.set(e,t);this.revision=e}async getRevision(){const e=await this.persistence.getItem(this.revisionKey);return e?function(e){const t=e.buffer;return new DataView(t).getInt32(0,!0)}(e):0}async setRevision(e){await this.persistence.setItem(this.revisionKey,function(e){const t=new ArrayBuffer(4);return new DataView(t).setInt32(0,e,!0),new Uint8Array(t)}(e))}async loadFromPersistence(){const e=await this.persistence.getItem(this.persistenceKey);return e?(e=>{const t=new Map;for(const[s,n]of Object.entries(e.topics))t.set(s,n);return t})(i.TopicMap.decode(e)):new Map}async store(){await this.persistence.setItem(this.persistenceKey,this.toBytes()),this.revision++,await this.setRevision(this.revision)}async add(e){await this.mutex.runExclusive((async()=>{await this.refresh();let t=!1;for(const s of e){if(!this.validate(s)){console.warn("Invalid topic data",s.topic);continue}const{topic:e,...n}=s;this.topicMap.has(e)||(this.topicMap.set(e,n),t=!0)}t&&await this.store()}))}get topics(){return[...this.topicMap.values()]}lookup(e){return this.topicMap.get(e)}toBytes(){return i.TopicMap.encode({topics:Object.fromEntries(this.topicMap)}).finish()}}class Ht extends Gt{static async create(e){const t=new Ht(e,"conversation-v1/v1");return await t.refresh(),t}validate(e){return!!(e.topic&&e.topic.length&&e.peerAddress?.length>0)}}const Ft=async(e,t,s,n)=>V(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!1),n),{ErrorCode:$t}=i,jt=(new TextEncoder).encode("__XMTP__INVITATION__SALT__XMTP__");class Xt{constructor(e,t,s,n){this.v1Keys=e,this.v2Keys=Oe.fromLegacyBundle(e),this.v1Store=t,this.v2Store=s,this.authenticator=new pt(e.identityKey),this.jobStatePersistence=n}static async create(e,t){return new Xt(e,await Ht.create(t),await Gt.create(t),t)}get walletAddress(){return this.v1Keys.identityKey.publicKey.walletSignatureAddress()}async decryptV1(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload","peerKeys"],["headerBytes"]);const{payload:t,peerKeys:s,headerBytes:n,isSender:r}=e,i=await(async(e,t,s,n,r)=>U(s,await e.sharedSecret(t,e.getCurrentPreKey().publicKey,!r),n))(this.v1Keys,Ut(s),t,n,r);return{decrypted:i}}),i.ErrorCode.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async decryptV2(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new ve(i.ErrorCode.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const o=await((e,t,s)=>U(e,t,s))(t,qt(r.invitation),s);return{decrypted:o}}),$t.ERROR_CODE_UNSPECIFIED);return i.DecryptResponse.fromPartial({responses:t})}async encryptV1(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload","recipient"],["headerBytes"]);const{recipient:t,payload:s,headerBytes:n}=e;return{encrypted:await Ft(this.v1Keys,Ut(t),s,n)}}),$t.ERROR_CODE_UNSPECIFIED);return i.EncryptResponse.fromPartial({responses:t})}async createAuthToken({timestampNs:e}){return this.authenticator.createToken(e?fe(e):void 0)}async selfEncrypt(e){const t=await Vt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new ve($t.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{encrypted:await Bt(this.v1Keys.identityKey,t)}}),$t.ERROR_CODE_INVALID_INPUT);return i.SelfEncryptResponse.fromPartial({responses:t})}async selfDecrypt(e){const t=await Vt(e.requests,(async e=>{const{payload:t}=e;if(!t)throw new ve($t.ERROR_CODE_INVALID_INPUT,"Missing field payload");return{decrypted:await Rt(this.v1Keys.identityKey,t)}}),$t.ERROR_CODE_INVALID_INPUT);return i.DecryptResponse.fromPartial({responses:t})}async getPrivatePreferencesTopicIdentifier(){const e=await async function(e){await C();const t=e.secp256k1.bytes;return B(t)}(this.v1Keys.identityKey);return i.GetPrivatePreferencesTopicIdentifierResponse.fromPartial({identifier:e})}async encryptV2(e){const t=await Vt(e.requests,(async e=>{Lt(e,["payload"],["headerBytes"]);const{payload:t,headerBytes:s,contentTopic:n}=e,r=this.v2Store.lookup(n);if(!r)throw new ve($t.ERROR_CODE_NO_MATCHING_PREKEY,"no topic key");const i=qt(r.invitation),o=await((e,t,s)=>V(e,t,s))(t,i,s),a=`${Math.floor(Date.now()/1e3/60/60/24/30)}-${await this.getAccountAddress()}`;return{encrypted:o,senderHmac:await G(i,(new TextEncoder).encode(a),s)}}),$t.ERROR_CODE_INVALID_INPUT);return i.EncryptResponse.fromPartial({responses:t})}async saveInvites(e){const t=[],s=await Vt(e.requests,(async({payload:e,timestampNs:s})=>{const n=Mt.fromBytes(e);if(n.v1){if(!n.v1.header.createdNs.equals(s))throw new Error("envelope and header timestamp mismatch");const e=n.v1.header.sender.equals(this.v2Keys.getPublicKeyBundle()),r=await n.v1.getInvitation(this.v2Keys),i={invitation:r,createdNs:n.v1.header.createdNs,peerAddress:e?await n.v1.header.recipient.walletSignatureAddress():await n.v1.header.sender.walletSignatureAddress()};return t.push({...i,topic:r.topic}),{conversation:Ot(i)}}}),$t.ERROR_CODE_INVALID_INPUT);return await this.v2Store.add(t),i.SaveInvitesResponse.fromPartial({responses:s})}async createInvite(e){try{Lt(e,["recipient"],[]);const s=fe(e.createdNs),n=(t=e.recipient)instanceof ce?t:new ce(t),r=await this.getAccountAddress(),o=await n.walletSignatureAddress(),a=await this.v2Keys.sharedSecret(n,this.v2Keys.getCurrentPreKey().publicKey,r<o),c=[r,o].sort(),d=(e.context?.conversationId||"")+c.join(),h=(new TextEncoder).encode(d),y=j(await Tt(Buffer.from(a),Buffer.from(h))),u=["0",...c].join("|"),l=(new TextEncoder).encode(u),p=await async function(e,t){const s=await D.subtle.importKey("raw",e,"HKDF",!1,["deriveKey"]);return D.subtle.deriveKey({name:"HKDF",hash:"SHA-256",salt:jt,info:t},s,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}(a,l),w=new Uint8Array(await D.subtle.exportKey("raw",p)),f=new Nt({topic:Ae(y),aes256GcmHkdfSha256:{keyMaterial:w},context:e.context,consentProof:e.consentProof}),m=await Mt.createV1({sender:this.v2Keys,recipient:n,created:s,invitation:f}),g={invitation:f,topic:f.topic,createdNs:e.createdNs,peerAddress:await n.walletSignatureAddress()};return await this.v2Store.add([g]),i.CreateInviteResponse.fromPartial({conversation:Ot(g),payload:m.toBytes()})}catch(e){throw _t(e,$t.ERROR_CODE_INVALID_INPUT)}var t}async signDigest(e){Lt(e,["digest"],[]);const{digest:t,identityKey:s,prekeyIndex:n}=e;let r;if(s)r=this.v1Keys.identityKey;else{if(void 0===n||!Number.isInteger(n))throw new ve($t.ERROR_CODE_INVALID_INPUT,"must specifify identityKey or prekeyIndex");if(r=this.v1Keys.preKeys[n],!r)throw new ve($t.ERROR_CODE_NO_MATCHING_PREKEY,"no prekey found")}return r.sign(t)}async saveV1Conversations({conversations:e}){return await this.v1Store.add(e.map((e=>({topic:ke(e.peerAddress,this.walletAddress),peerAddress:e.peerAddress,createdNs:e.createdNs,invitation:void 0})))),{}}async getV1Conversations(){return{conversations:this.v1Store.topics.map(this.topicDataToV1ConversationReference.bind(this))}}async getV2Conversations(){const e=this.v2Store.topics.map((e=>Ot(e)));return e.sort(((e,t)=>e.createdNs.div(1e6).sub(t.createdNs.div(1e6)).toNumber())),i.GetConversationsResponse.fromPartial({conversations:e})}async getPublicKeyBundle(){return this.v1Keys.getPublicKeyBundle()}async getPrivateKeyBundle(){return this.v1Keys}async getAccountAddress(){return this.accountAddress||(this.accountAddress=await this.v2Keys.getPublicKeyBundle().walletSignatureAddress()),this.accountAddress}async getRefreshJob({jobType:e}){if(e===i.JobType.JOB_TYPE_UNSPECIFIED)throw new ve($t.ERROR_CODE_INVALID_INPUT,"invalid job type");const t=await this.getLastRunTime(e);return i.GetRefreshJobResponse.fromPartial({lastRunNs:t||l.fromNumber(0)})}async setRefreshJob({jobType:e,lastRunNs:t}){const s=await this.buildJobStorageKey(e);return await this.jobStatePersistence.setItem(s,Uint8Array.from(t.toBytes())),{}}topicDataToV1ConversationReference(e){return{peerAddress:e.peerAddress,createdNs:e.createdNs,topic:ke(e.peerAddress,this.walletAddress),context:void 0,consentProofPayload:void 0}}buildJobStorageKey(e){return`refreshJob/${e.toString()}`}async getLastRunTime(e){const t=await this.jobStatePersistence.getItem(this.buildJobStorageKey(e));if(t&&t.length)return l.fromBytes([...t])}lookupTopic(e){return this.v2Store.lookup(e)}async getV2ConversationHmacKeys(e){const t=Math.floor(Date.now()/1e3/60/60/24/30),s={};let n=this.v2Store.topics;return e?.topics&&(n=n.filter((t=>void 0!==t.invitation&&e.topics.includes(t.invitation.topic)))),await Promise.all(n.map((async e=>{if(e.invitation?.topic){const n=qt(e.invitation),r=await Promise.all([t-1,t,t+1].map((async e=>{const t=`${e}-${await this.getAccountAddress()}`,s=await O(n,(new TextEncoder).encode(t));return{thirtyDayPeriodsSinceEpoch:e,hmacKey:await F(s)}})));s[e.invitation.topic]={values:r}}}))),{hmacKeys:s}}}class Jt{constructor(e){this.apiClient=e}async getItem(e){for await(const t of this.apiClient.queryIterator({contentTopic:this.buildTopic(e)},{pageSize:1,direction:d.SortDirection.SORT_DIRECTION_DESCENDING}))if(t.message)try{return Uint8Array.from(t.message)}catch(e){console.log(e)}return null}async setItem(e,t){const s=Uint8Array.from(t);await this.apiClient.publish([{contentTopic:this.buildTopic(e),message:s}])}setAuthenticator(e){this.apiClient.setAuthenticator(e)}buildTopic(e){return Pe(e)}}class zt{constructor({eciesBytes:t,signature:s}){if(!t||!t.length)throw new Error("eciesBytes is empty");if(!s)throw new Error("signature is undefined");this.eciesBytes=t,this.signature=new te(s),this.ciphertext=e.SignedEciesCiphertext_Ecies.decode(t)}toBytes(){return e.SignedEciesCiphertext.encode(this).finish()}async verify(e){return e.verify(this.signature,await _(this.eciesBytes))}static fromBytes(t){const s=e.SignedEciesCiphertext.decode(t);return new zt(s)}static async create(t,s){(e=>{if(16!==e.iv.length)throw new Error("Invalid iv length");if(65!==e.ephemeralPublicKey.length)throw new Error("Invalid ephemPublicKey length");if(e.ciphertext.length<1||e.ciphertext.length%16!=0)throw new Error("Invalid ciphertext length");if(32!==e.mac.length)throw new Error("Invalid mac length")})(t);const n=e.SignedEciesCiphertext_Ecies.encode(t).finish(),r=await s.sign(await _(n));return new zt({eciesBytes:n,signature:r})}}class Yt{constructor(e,t){this.persistence=e,this.privateKey=t,this.privateKeyBytes=Buffer.from(t.secp256k1.bytes),this.publicKey=Ct(this.privateKeyBytes)}async getItem(e){const t=await this.persistence.getItem(e);return t?this.decrypt(t):null}async setItem(e,t){const s=await this.encrypt(t);await this.persistence.setItem(e,s)}async encrypt(e){const t=await async function(e,t,s){s=s||{};const n=s?.iv||Et(16);let r=s?.ephemPrivateKey||Et(32);for(;!bt(r);){if(s?.ephemPrivateKey)throw new Error("ephemPrivateKey is not valid");r=Et(32)}const i=Ct(r),o=await Kt(await Pt(r,e)),a=o.slice(0,32),c=o.slice(32),d=await At(n,a,t),h=Buffer.concat([n,i,d]);return{iv:n,ephemeralPublicKey:i,ciphertext:d,mac:await Tt(c,h)}}(this.publicKey,Buffer.from(e));return this.serializeEcies(t)}async decrypt(e){const t=await this.deserializeEcies(e),s=await It(this.privateKeyBytes,t);return Uint8Array.from(s)}async serializeEcies(e){return(await zt.create(e,this.privateKey)).toBytes()}async deserializeEcies(e){const t=zt.fromBytes(e);if(!await t.verify(this.privateKey.publicKey))throw new Error("signature validation failed");const s=t.ciphertext;return{ciphertext:Buffer.from(s.ciphertext),mac:Buffer.from(s.mac),iv:Buffer.from(s.iv),ephemeralPublicKey:Buffer.from(s.ephemeralPublicKey)}}}class Wt{constructor(e,t){this.prefix=e,this.persistence=t}getItem(e){return this.persistence.getItem(this.buildKey(e))}setItem(e,t){return this.persistence.setItem(this.buildKey(e),t)}buildKey(e){return this.prefix+e}}const Qt=async(e,t)=>{if(!e.persistConversations)return ut.create();const s=await t.identityKey.publicKey.walletSignatureAddress(),n=`xmtp/${e.env}/${s}/`;const r=e.basePersistence,i=!e.disablePersistenceEncryption;return new Wt(n,i?new Yt(r,t.identityKey):r)},Zt="key_bundle";class es{constructor(e,t,s){this.signer=e,this.persistence=t,this.preEnableIdentityCallback=s}async getStorageAddress(e){let t=await this.signer.getAddress();return t=m(t),`${t}/${e}`}async loadPrivateKeyBundle(){const e=await this.persistence.getItem(await this.getStorageAddress(Zt));if(!e)return null;const[t,s]=await this.fromEncryptedBytes(this.signer,Uint8Array.from(e));return s&&await this.storePrivateKeyBundle(t),t}async storePrivateKeyBundle(e){const t=await this.getStorageAddress(Zt),s=await this.toEncryptedBytes(e,this.signer);"function"==typeof this.persistence.setAuthenticator&&this.persistence.setAuthenticator(new pt(e.identityKey)),await this.persistence.setItem(t,s)}async toEncryptedBytes(e,s){const n=e.encode(),r=D.getRandomValues(new Uint8Array(32)),i=ss(r),o=await s.getAddress();this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const a=await s.signMessage(i);if(!E({address:o,message:i,signature:a}))throw new Error("invalid signature");const c=v(a),d=await V(n,c);return t.EncryptedPrivateKeyBundle.encode({v1:{walletPreKey:r,ciphertext:d}}).finish()}async fromEncryptedBytes(e,s){const[n,r]=function(e){try{const s=t.EncryptedPrivateKeyBundle.decode(e);if(s.v1)return[s.v1,!1]}catch(s){return[t.EncryptedPrivateKeyBundleV1.decode(e),!0]}throw new Error("unrecognized encrypted private key bundle version")}(s);if(!n.walletPreKey)throw new Error("missing wallet pre-key");if(!n.ciphertext?.aes256GcmHkdfSha256)throw new Error("missing bundle ciphertext");this.preEnableIdentityCallback&&await this.preEnableIdentityCallback();const i=v(await e.signMessage(ss(n.walletPreKey)));try{const e=new N(n.ciphertext),t=await U(e,i),[s,o]=ts(t);return[s,r||o]}catch(e){if(65!==i.length)throw new Error("Expected 65 bytes before trying a different recovery byte");const t=i[i.length-1];let s=i.slice(0,i.length-1);s=t<27?new Uint8Array([...s,t+27]):new Uint8Array([...s,t-27]);const o=new N(n.ciphertext),a=await U(o,s),[c,d]=ts(a);return[c,r||d]}}}function ts(e){try{const t=He(e);if(t instanceof Oe)throw new Error("V2 bundles not supported yet");return[t,!1]}catch(s){const n=t.PrivateKeyBundleV1.decode(e);return[new Ge(n),!0]}}function ss(e){return`XMTP : Enable Identity\n${j(e)}\n\nFor more info: https://xmtp.org/signatures/`}class ns{async newKeystore(e,t,s){if(!s)throw new lt("Wallet required to generate new keys");e.preCreateIdentityCallback&&await e.preCreateIdentityCallback();const n=await Ge.generate(s),r=new es(s,new Jt(t),e.preEnableIdentityCallback);return await r.storePrivateKeyBundle(n),Xt.create(n,await Qt(e,n))}}class rs{async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");const n=new es(s,new Jt(t),e.preEnableIdentityCallback),r=await n.loadPrivateKeyBundle();if(!r)throw new lt("No keys found");return Xt.create(r,await Qt(e,r))}}function is(){return window.ethereum}function os(e){const[t,s,...n]=e.split(".");return{major:Number(t),minor:Number(s),patch:n.join(".")}}function as(e,t){if(!e||!t)return!1;const s=os(e),n=os(t);return s.major!==n.major?s.major>n.major:s.minor!==n.minor?s.minor>n.minor:!(!s.patch||!n.patch)&&function(e,t){const[s,n]=e.split("-"),[r,i]=t.split("-");if(Number(s)!==Number(r))return Number(s)>Number(r);if(!n||!i)return!1;const[o,a]=n.split("."),[c,d]=i.split(".");if(o!==c)return!0;return Number(a)>Number(d)}(s.patch,n.patch)}const{GetKeystoreStatusResponse_KeystoreStatus:cs,InitKeystoreRequest:ds,InitKeystoreResponse:hs,GetKeystoreStatusRequest:ys,GetKeystoreStatusResponse:us}=i;async function ls(e,t,s,n,r){let i=null;if(t.req){const e=(0,t.req.encode)(s).finish();i=le(e,0,e.length)}const o=await async function(e,t,s,n){const r={meta:s};"string"==typeof t&&(r.req=t);const i=await(is()?.request({method:"wallet_invokeSnap",params:{snapId:n,request:{method:e,params:r}}}));if(!i||"object"!=typeof i)throw new Error("No response value");return i.res}(e,i,n,r);if(Array.isArray(o))throw new Error("Unexpected array response");return t.res.decode(ue(o))}async function ps(){const e=is();if(e?.isMetaMask)try{return await e.request({method:"wallet_getSnaps"}),!0}catch{}if(void 0!==e?.detected&&Array.isArray(e.detected))for(const t of e.detected)try{return await t.request({method:"wallet_getSnaps"}),e?.setProvider?.(t),!0}catch{}if(void 0!==e?.providers&&Array.isArray(e.providers))for(const t of e.providers)try{return await t.request({method:"wallet_getSnaps"}),window.ethereum=t,!0}catch{}return!1}async function ws(e,t){try{const s=await async function(){return await(is()?.request({method:"wallet_getSnaps"}))}();return s?Object.values(s).find((s=>{return s&&s.id===e&&(!t||(n=s.version,r=t,!n||!r||os(n).major===os(r).major));var n,r})):void 0}catch(e){return void console.warn("Failed to obtain installed snap",e)}}const fs={req:ys,res:us};const ms={req:ds,res:hs};const gs={decryptV1:{req:i.DecryptV1Request,res:i.DecryptResponse},decryptV2:{req:i.DecryptV2Request,res:i.DecryptResponse},encryptV1:{req:i.EncryptV1Request,res:i.EncryptResponse},encryptV2:{req:i.EncryptV2Request,res:i.EncryptResponse},saveInvites:{req:i.SaveInvitesRequest,res:i.SaveInvitesResponse},createInvite:{req:i.CreateInviteRequest,res:i.CreateInviteResponse},createAuthToken:{req:i.CreateAuthTokenRequest,res:c.Token},signDigest:{req:i.SignDigestRequest,res:s.Signature},getPublicKeyBundle:{req:null,res:n.PublicKeyBundle},getPrivateKeyBundle:{req:null,res:t.PrivateKeyBundleV1},saveV1Conversations:{req:i.SaveV1ConversationsRequest,res:i.SaveV1ConversationsResponse},getV1Conversations:{req:null,res:i.GetConversationsResponse},getV2Conversations:{req:null,res:i.GetConversationsResponse},getRefreshJob:{req:i.GetRefreshJobRequest,res:i.GetRefreshJobResponse},setRefreshJob:{req:i.SetRefeshJobRequest,res:i.SetRefreshJobResponse},selfEncrypt:{req:i.SelfEncryptRequest,res:i.SelfEncryptResponse},selfDecrypt:{req:i.SelfDecryptRequest,res:i.DecryptResponse},getPrivatePreferencesTopicIdentifier:{req:null,res:i.GetPrivatePreferencesTopicIdentifierResponse},getV2ConversationHmacKeys:{req:i.GetConversationHmacKeysRequest,res:i.GetConversationHmacKeysResponse}},vs={...gs,getKeystoreStatus:{req:i.GetKeystoreStatusRequest,res:i.GetKeystoreStatusResponse},initKeystore:{req:i.InitKeystoreRequest,res:i.InitKeystoreResponse}};const{GetKeystoreStatusResponse_KeystoreStatus:bs}=i;class Es{constructor(e="local:http://localhost:8080",t){this.snapId=e,this.snapVersion=t}async newKeystore(e,t,s){if(!s)throw new lt("No wallet provided");if(!await ps())throw new lt("MetaMask with Snaps not detected");const n=await s.getAddress(),r=e.env,i=await ws(this.snapId,this.snapVersion);if(i&&!as(this.snapVersion,i.version)||await async function(e,t={}){await(is()?.request({method:"wallet_requestSnaps",params:{[e]:t}}))}(this.snapId,this.snapVersion?{version:this.snapVersion}:{}),!await async function(e,t,s){const n=await async function(e,t){const s=await ls("getKeystoreStatus",fs,{walletAddress:e.walletAddress},e,t);if([cs.KEYSTORE_STATUS_UNSPECIFIED,cs.UNRECOGNIZED].includes(s.status))throw new Error("No status specified in response");return s.status}({walletAddress:e,env:t},s);if(n===bs.KEYSTORE_STATUS_INITIALIZED)return!0;return!1}(n,r,this.snapId)){const n=await async function(e,t,s){if(e.privateKeyOverride){const t=He(e.privateKeyOverride);if(!(t instanceof Ge))throw new Error("Unsupported private key bundle version");return t}if(!s)throw new Error("No privateKeyOverride or wallet");return async function(e,t,s){const n=new rs;try{const r=await n.newKeystore(e,t,s);return new Ge(await r.getPrivateKeyBundle())}catch(n){if(n instanceof lt)return async function(e,t,s){const n=new ns,r=await n.newKeystore(e,t,s);return new Ge(await r.getPrivateKeyBundle())}(e,t,s);throw n}}(e,t,s)}(e,t,s);await async function(e,t,s){const n=e.identityKey.publicKey.walletSignatureAddress(),r=await ls("initKeystore",ms,{v1:e},{walletAddress:n,env:t},s);if(r.error)throw new ve(r.error.code,r.error.message)}(n,r,this.snapId)}return function(e,t,s){const n={},r={walletAddress:e,env:t};for(const[e,t]of Object.entries(vs))n[e]=async n=>t.req?ls(e,t,n,r,s):ls(e,t,void 0,r,s);return{...n,getAccountAddress:async()=>e}}(n,r,this.snapId)}}class Ks{async newKeystore(e){const{privateKeyOverride:t}=e;if(!t)throw new lt("No private key override provided");const s=He(t);if(s instanceof Oe)throw new Error("V2 private key bundle found. Only V1 supported");return Xt.create(s,await Qt(e,s))}}function ks(e){if(!e)return null;if(function(e){return"type"in e&&("walletClient"===e.type||"base"===e.type)}(e))return function(e){const{account:t}=e;if(!t||!t.address)throw new Error("WalletClient is not configured");return{getAddress:async()=>t.address,signMessage:async s=>e.signMessage({message:"string"==typeof s?s:{raw:s},account:t})}}(e);if("function"!=typeof e.getAddress)throw new Error("Unknown wallet type");return e}function As(e){if(e===a.Compression.COMPRESSION_GZIP)return"gzip";if(e===a.Compression.COMPRESSION_DEFLATE)return"deflate";throw new Error("unrecognized compression algorithm")}function Ss(e,t=1024){let s=0;return new ReadableStream({pull(n){if(s>=e.length)return n.close();let r=s+t;r=r<=e.length?r:e.length,n.enqueue(e.subarray(s,r)),s=r}})}function Ts(e,t){let s=0;return new WritableStream({write(n){const r=s+n.length;if(r>t)throw new Error("maximum output size exceeded");for(;e.bytes.length<r;)e.bytes=Cs(e.bytes,t);e.bytes.set(n,s),s=r},close(){s<e.bytes.length&&(e.bytes=e.bytes.subarray(0,s))}})}function Cs(e,t){let s=2*e.length;s>t&&(s=t);const n=new Uint8Array(s);return n.set(e),n}function Ps(e){let t;try{t=y.ContactBundle.decode(e)}catch(s){const r=n.PublicKeyBundle.decode(e);t={v1:{keyBundle:new de(r)},v2:void 0}}if(t.v1?.keyBundle)return new de(t.v1.keyBundle);if(t.v2?.keyBundle)return new ce(t.v2.keyBundle);throw new Error("unknown or invalid contact bundle")}function Is(e){return e instanceof de?y.ContactBundle.encode({v1:{keyBundle:e},v2:void 0}).finish():y.ContactBundle.encode({v1:void 0,v2:{keyBundle:e}}).finish()}class Bs{constructor(e,t,s){this.value=e,this.entryType=t,this.permissionType=s}get key(){return`${this.entryType}-${this.value}`}static fromAddress(e,t="unknown"){return new Bs(e,"address",t)}static fromGroupId(e,t="unknown"){return new Bs(e,"groupId",t)}static fromInboxId(e,t="unknown"){return new Bs(e,"inboxId",t)}}class Rs{constructor(e){this.entries=new Map,this.client=e}allow(e){const t=Bs.fromAddress(e,"allowed");return this.entries.set(t.key,"allowed"),t}deny(e){const t=Bs.fromAddress(e,"denied");return this.entries.set(t.key,"denied"),t}allowGroup(e){const t=Bs.fromGroupId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyGroup(e){const t=Bs.fromGroupId(e,"denied");return this.entries.set(t.key,"denied"),t}allowInboxId(e){const t=Bs.fromInboxId(e,"allowed");return this.entries.set(t.key,"allowed"),t}denyInboxId(e){const t=Bs.fromInboxId(e,"denied");return this.entries.set(t.key,"denied"),t}state(e){const t=Bs.fromAddress(e);return this.entries.get(t.key)??"unknown"}groupState(e){const t=Bs.fromGroupId(e);return this.entries.get(t.key)??"unknown"}inboxIdState(e){const t=Bs.fromInboxId(e);return this.entries.get(t.key)??"unknown"}async getIdentifier(){if(!this._identifier){const{identifier:e}=await this.client.keystore.getPrivatePreferencesTopicIdentifier();this._identifier=e}return this._identifier}async decodeMessages(e){const{responses:t}=await this.client.keystore.selfDecrypt({requests:e.map((e=>({payload:e})))});return t.reduce(((e,t)=>t.result?.decrypted?e.concat(u.PrivatePreferencesAction.decode(t.result.decrypted)):e),[])}processActions(e,t){const s=[];return e.forEach((e=>{e.allowAddress?.walletAddresses.forEach((e=>{s.push(this.allow(e))})),e.denyAddress?.walletAddresses.forEach((e=>{s.push(this.deny(e))})),e.allowGroup?.groupIds.forEach((e=>{s.push(this.allowGroup(e))})),e.denyGroup?.groupIds.forEach((e=>{s.push(this.denyGroup(e))})),e.allowInboxId?.inboxIds.forEach((e=>{s.push(this.allowInboxId(e))})),e.denyInboxId?.inboxIds.forEach((e=>{s.push(this.denyInboxId(e))}))})),t&&(this.lastEntryTimestamp=ge(t)),s}async stream(e){const t=await this.getIdentifier(),s=Ie(t);return ye.create(this.client,[s],(async e=>{if(!e.message)return;const t=await this.decodeMessages([e.message]);return this.processActions(t,e.timestampNs),t[0]}),void 0,e)}reset(){this.entries.clear()}async load(e){const t=await this.getIdentifier(),s=Ie(t);let n;const r=await this.client.listEnvelopes(s,(async({message:e,timestampNs:t})=>(t&&(n=t),e)),{startTime:e}),i=await this.decodeMessages(r);return this.processActions(i,n)}async publish(e){const t=await this.getIdentifier(),s=e.reduce(((e,t)=>{let s,n,r;if("unknown"===t.permissionType)return e;switch(t.entryType){case"address":s="allowed"===t.permissionType?"allowAddress":"denyAddress",n="walletAddresses",r=e[s]?.[n]??[];break;case"groupId":s="allowed"===t.permissionType?"allowGroup":"denyGroup",n="groupIds",r=e[s]?.[n]??[];break;case"inboxId":s="allowed"===t.permissionType?"allowInboxId":"denyInboxId",n="inboxIds",r=e[s]?.[n]??[];break;default:return e}return{...e,[s]:{[n]:[...r,t.value]}}}),{}),n=u.PrivatePreferencesAction.encode(s).finish(),{responses:r}=await this.client.keystore.selfEncrypt({requests:[{payload:n}]}),i=r.reduce(((e,t)=>t.result?.encrypted?e.concat(t.result?.encrypted):e),[]),o=Ie(t),a=new Date,c=i.map((e=>({contentTopic:o,message:e,timestamp:a})));await this.client.publishEnvelopes(c),e.forEach((e=>{this.entries.set(e.key,e.permissionType)}))}}class Ns{constructor(e){this.addresses=new Set,this.consentList=new Rs(e),this.client=e,this.jobRunner=new at("user-preferences",e.keystore)}validateConsentSignature({signature:e,timestamp:t},s){const n=Number(t);if(!e||!n)return!1;if(n>Date.now())return!1;if(n<Date.now()-2592e6)return!1;const r=J(e),i=R(s,n),o=ee(v(b(i)),r);return o?.getEthereumAddress()===this.client.address}async loadConsentList(e){return this.jobRunner.run((async t=>{const s=await this.consentList.load(e??t);try{const e=(await this.client.conversations.list()).reduce(((e,t)=>t.consentProof&&"unknown"===this.consentState(t.peerAddress)&&this.validateConsentSignature(t.consentProof,t.peerAddress)?e.concat(t.peerAddress):e),[]);e.length&&await this.client.contacts.allow(e)}catch(e){console.log(e)}return s}))}async refreshConsentList(){return this.consentList.reset(),await this.jobRunner.resetLastRunTime(),this.loadConsentList()}async streamConsentList(e){return this.consentList.stream(e)}get lastConsentListEntryTimestamp(){return this.consentList.lastEntryTimestamp}setConsentListEntries(e){e.length&&(this.consentList.reset(),e.forEach((e=>{"allowed"===e.permissionType&&this.consentList.allow(e.value),"denied"===e.permissionType&&this.consentList.deny(e.value)})))}isAllowed(e){return"allowed"===this.consentList.state(e)}isDenied(e){return"denied"===this.consentList.state(e)}isGroupAllowed(e){return"allowed"===this.consentList.groupState(e)}isGroupDenied(e){return"denied"===this.consentList.groupState(e)}isInboxAllowed(e){return"allowed"===this.consentList.inboxIdState(e)}isInboxDenied(e){return"denied"===this.consentList.inboxIdState(e)}consentState(e){return this.consentList.state(e)}groupConsentState(e){return this.consentList.groupState(e)}inboxConsentState(e){return this.consentList.inboxIdState(e)}async allow(e){await this.consentList.publish(e.map((e=>Bs.fromAddress(e,"allowed"))))}async deny(e){await this.consentList.publish(e.map((e=>Bs.fromAddress(e,"denied"))))}async allowGroups(e){await this.consentList.publish(e.map((e=>Bs.fromGroupId(e,"allowed"))))}async denyGroups(e){await this.consentList.publish(e.map((e=>Bs.fromGroupId(e,"denied"))))}async allowInboxes(e){await this.consentList.publish(e.map((e=>Bs.fromInboxId(e,"allowed"))))}async denyInboxes(e){await this.consentList.publish(e.map((e=>Bs.fromInboxId(e,"denied"))))}}var Ds;!function(e){e[e.none=0]="none",e[e.xmtpTopicStore=1]="xmtpTopicStore"}(Ds||(Ds={}));const xs=Ds.none;class Ms{static createConfiguration(){return{type:xs,version:0}}constructor(e){this.configuration=e}get backupType(){return xs}}const _s=Ds.xmtpTopicStore;class Vs{static createConfiguration(e){return{type:_s,version:0,topic:"history-v0:"+e}}constructor(e){this.configuration=e}get backupType(){return _s}}async function Us(e,t){const s=await async function(e,t){let s;switch((await t()).type){case Ds.none:s=Ms.createConfiguration();break;case Ds.xmtpTopicStore:s=Vs.createConfiguration(e)}return s}(e,t);switch(s.type){case Ds.none:return new Ms(s);case Ds.xmtpTopicStore:return new Vs(s)}}const{Compression:Ls}=a,qs=104857600;class Os{constructor(e,t,s,n){this.knownPublicKeyBundles=new Map,this.keystore=n,this.publicKeyBundle=e,this.address=e.walletSignatureAddress(),this._conversations=new dt(this),this._codecs=new Map,this._maxContentSize=qs,this.apiClient=t,this._backupClient=s,this.contacts=new Ns(this)}get conversations(){return this._conversations}get backupType(){return this._backupClient.backupType}get signedPublicKeyBundle(){return ce.fromLegacyBundle(this.publicKeyBundle)}static async create(e,t){const s=ks(e),n=function(e){const t={privateKeyOverride:void 0,env:"dev",apiUrl:void 0,codecs:[new k],maxContentSize:qs,persistConversations:!0,skipContactPublishing:!1,useSnaps:!1,basePersistence:"undefined"!=typeof window&&void 0!==window.document?ht.create():ut.create(),disablePersistenceEncryption:!1,keystoreProviders:$s(),apiClientFactory:Gs};return e?.codecs&&(e.codecs=t.codecs.concat(e.codecs)),e?.useSnaps&&(e.keystoreProviders=[new Es("npm:@xmtp/snap","1.3.6"),...t.keystoreProviders]),{...t,...e}}(t),r=n.apiClientFactory(n),i=await async function(e,t,s){for(const n of e.keystoreProviders)try{return await n.newKeystore(e,t,s??void 0)}catch(e){if(e instanceof lt)continue;throw e}throw new Error("No keystore providers available")}(n,r,s),o=new de(await i.getPublicKeyBundle()),a=o.walletSignatureAddress();r.setAuthenticator(new je(i));const c=await Os.setupBackupClient(a,n.env),d=new Os(o,r,c,i);return await d.init(n),d}static async getKeys(e,t){const s=await Os.create(ks(e),t),n=await s.keystore.getPrivateKeyBundle();return new Ge(n).encode()}static isSnapsReady(){return ps()}static async setupBackupClient(e,t){return Us(e,(async()=>Promise.resolve({type:"local"===t?Ds.xmtpTopicStore:Ds.none})))}async init(e){e.codecs.forEach((e=>{this.registerCodec(e)})),this._maxContentSize=e.maxContentSize,e.skipContactPublishing||await this.ensureUserContactPublished(e.publishLegacyContact)}async close(){}async ensureUserContactPublished(e=!1){const t=await Hs(this.apiClient,this.address);t&&t instanceof ce&&this.signedPublicKeyBundle.equals(t)||(await this.publishUserContact(!0),e||await this.publishUserContact(e))}async publishUserContact(e=!1){const t=e?this.publicKeyBundle:this.signedPublicKeyBundle;await this.publishEnvelopes([{contentTopic:Se(this.address),message:Is(t)}])}async getUserContact(e){e=m(e);const t=this.knownPublicKeyBundles.get(e);if(t)return t;const s=await Hs(this.apiClient,e);return s&&this.knownPublicKeyBundles.set(e,s),s}async getUserContacts(e){const t=e.map((e=>m(e))),s=new Map,n=[];for(const e of t){const t=this.knownPublicKeyBundles.get(e);t?s.set(e,t):(s.set(e,void 0),n.push(e))}const r=await Fs(this.apiClient,n);for(let e=0;e<r.length;e++){const t=n[e],i=r[e];s.set(t,i),i&&this.knownPublicKeyBundles.set(t,i)}return t.map((e=>s.get(e)))}forgetContact(e){e=m(e),this.knownPublicKeyBundles.delete(e)}async canMessage(e){try{if(Array.isArray(e)){return(await this.getUserContacts(e)).map((e=>!!e))}return void 0!==await this.getUserContact(e)}catch(e){return!1}}static async canMessage(e,t){const s=t?.apiUrl||et[t?.env||"dev"],n=new ot(s,{appVersion:t?.appVersion});if(Array.isArray(e)){const t=e.map((e=>m(e)));return(await Fs(n,t)).map((e=>!!e))}try{e=m(e)}catch(e){return!1}return void 0!==await Hs(n,e)}validateEnvelope(e){const t=e.message;if(!e.contentTopic)throw new Error("Missing content topic");if(!t||!t.length)throw new Error("Cannot publish empty message")}async publishEnvelopes(e){for(const t of e)this.validateEnvelope(t);await this.apiClient.publish(e)}registerCodec(e){const t=e.contentType,s=`${t.authorityId}/${t.typeId}`;return this._codecs.set(s,e),this}codecFor(e){const t=`${e.authorityId}/${e.typeId}`,s=this._codecs.get(t);if(s&&!(e.versionMajor>s.contentType.versionMajor))return s}async encodeContent(e,t){const s=t?.contentType||K,n=this.codecFor(s);if(!n)throw new Error("unknown content type "+s);const r=n.encode(e,this),i=n.fallback(e);return i&&(r.fallback=i),"number"==typeof t?.compression&&r.content.length>=10&&(r.compression=t.compression),await async function(e){if(void 0===e.compression)return;const t={bytes:new Uint8Array(e.content.length/10)};await Ss(e.content).pipeThrough(new CompressionStream(As(e.compression))).pipeTo(Ts(t,e.content.length+1e3)),e.content=t.bytes}(r),{payload:a.EncodedContent.encode(r).finish(),shouldPush:n.shouldPush(e)}}async decodeContent(e){const t=a.EncodedContent.decode(e);if(!t.type)throw new Error("missing content type");let s;const n=new A(t.type);let r;await async function(e,t){if(void 0===e.compression)return;const s={bytes:new Uint8Array(e.content.length)};await Ss(e.content).pipeThrough(new DecompressionStream(As(e.compression))).pipeTo(Ts(s,t)),e.content=s.bytes}(t,1e3);const i=this.codecFor(n);return i?s=i.decode(t,this):r=new Error("unknown content type "+n),{content:s,contentType:n,error:r,contentFallback:t.fallback}}listInvitations(e){return this.listEnvelopes(Ce(this.address),(async e=>e),e)}async listEnvelopes(e,t,s){s||(s={});const{startTime:n,endTime:r,limit:i}=s,o=await this.apiClient.query({contentTopic:e,startTime:n,endTime:r},{direction:s.direction||d.SortDirection.SORT_DIRECTION_ASCENDING,limit:i}),a=[];for(const e of o)if(e.message)try{const s=await t(e);a.push(s)}catch(e){console.warn("Error in listEnvelopes mapper",e)}return a}listEnvelopesPaginated(e,t,s){return Ye(this.apiClient.queryIteratePages({contentTopic:e,startTime:s?.startTime,endTime:s?.endTime},{direction:s?.direction,pageSize:s?.pageSize||100}),t)}}function Gs(e){const t=e.apiUrl||et[e.env];return new ot(t,{appVersion:e.appVersion})}async function Hs(e,t){const s=e.queryIterator({contentTopic:Se(t)},{pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING});for await(const e of s){if(!e.message)continue;const s=Ps(e.message);let n;try{n=await(s?.walletSignatureAddress())}catch(e){n=void 0}if(n?.toLowerCase()===t.toLowerCase())return s}}async function Fs(e,t){const s=t.map(Se),n=await e.batchQuery(s.map((e=>({contentTopic:e,pageSize:5,direction:Ze.SORT_DIRECTION_DESCENDING}))));return Promise.all(t.map((async(e,t)=>{const s=n[t];if(s)for(const t of s)if(t.message)try{const s=Ps(t.message),n=await(s?.walletSignatureAddress());if(e.toLowerCase()===n.toLowerCase())return s;console.info("Received contact bundle with incorrect address")}catch(e){console.info("Invalid contact bundle",e)}})))}function $s(){return[new Ks,new rs,new ns]}export{et as ApiUrls,We as AuthCache,ht as BrowserStoragePersistence,N as Ciphertext,Os as Client,Ls as Compression,Bs as ConsentListEntry,Re as ConversationV1,Ne as ConversationV2,dt as Conversations,Ve as DecodedMessage,Yt as EncryptedPersistence,ot as HttpApiClient,Xt as InMemoryKeystore,ut as InMemoryPersistence,Nt as InvitationV1,ns as KeyGeneratorKeystoreProvider,pt as LocalAuthenticator,Me as MessageV1,_e as MessageV2,rs as NetworkKeystoreProvider,Wt as PrefixedPersistence,W as PrivateKey,Ge as PrivateKeyBundleV1,Oe as PrivateKeyBundleV2,ae as PublicKey,de as PublicKeyBundle,Mt as SealedInvitation,te as Signature,oe as SignedPublicKey,ce as SignedPublicKeyBundle,Es as SnapProvider,Ze as SortDirection,Ks as StaticKeystoreProvider,ye as Stream,Ke as buildContentTopic,ke as buildDirectMessageTopic,Ae as buildDirectMessageTopicV2,Se as buildUserContactTopic,Te as buildUserIntroTopic,Ce as buildUserInviteTopic,Pe as buildUserPrivateStoreTopic,we as dateToNs,Ps as decodeContactBundle,Le as decodeContent,U as decrypt,$s as defaultKeystoreProviders,V as encrypt,F as exportHmacKey,ge as fromNanoString,G as generateHmacSignature,O as hkdfHmacKey,$ as importHmacKey,gs as keystoreApiDefs,Ye as mapPaginatedStream,fe as nsToDate,ze as retry,vs as snapKeystoreApiDefs,me as toNanoString,H as verifyHmacSignature};
 //# sourceMappingURL=index.js.map
