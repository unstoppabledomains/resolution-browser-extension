diff --git a/dist/browser/index.js b/dist/browser/index.js
index 478828f866b946a5c53f77d8bdf66cd8a27f7089..9a4f407d78b7690cabaddd1edd9442d70cd7de11 100644
--- a/dist/browser/index.js
+++ b/dist/browser/index.js
@@ -1,2 +1,2 @@
-import{ContentTypeId as e}from"@xmtp/content-type-primitives";import*as t from"@noble/secp256k1";import{content as n}from"@xmtp/proto";import{Ciphertext as r,decrypt as o,encrypt as a}from"@xmtp/xmtp-js";const s=new e({authorityId:"xmtp.org",typeId:"attachment",versionMajor:1,versionMinor:0});class c{get contentType(){return s}encode(e){return{type:s,parameters:{filename:e.filename,mimeType:e.mimeType},content:e.data}}decode(e){return{filename:e.parameters.filename,mimeType:e.parameters.mimeType,data:e.content}}fallback(e){return`Can’t display "${e.filename}". This app doesn’t support attachments.`}shouldPush(){return!0}}const i=window.crypto,m=new e({authorityId:"xmtp.org",typeId:"remoteStaticAttachment",versionMajor:1,versionMinor:0});class p{static async load(a,s){const c=await fetch(a.url),m=new Uint8Array(await c.arrayBuffer());if(!m)throw new Error(`no payload for remote attachment at ${a.url}`);const p=new Uint8Array(await i.subtle.digest("SHA-256",m));if(t.utils.bytesToHex(p)!==a.contentDigest)throw new Error("content digest does not match");const d=new r({aes256GcmHkdfSha256:{hkdfSalt:a.salt,gcmNonce:a.nonce,payload:m}}),l=await o(d,a.secret),h=n.EncodedContent.decode(l);if(!h||!h.type)throw new Error("no encoded content");const y=h.type;if(!y)throw new Error("no content type");const u=s.codecFor(new e(y));if(!u)throw new Error(`no codec found for ${h.type?.typeId}`);return u.decode(h,s)}static async encodeEncrypted(e,r){const o=i.getRandomValues(new Uint8Array(32)),s=n.EncodedContent.encode(r.encode(e,{codecFor(){}})).finish(),c=await a(s,o),m=c.aes256GcmHkdfSha256?.hkdfSalt,p=c.aes256GcmHkdfSha256?.gcmNonce,d=c.aes256GcmHkdfSha256?.payload;if(!m||!p||!d)throw new Error("missing encryption key");const l=new Uint8Array(await i.subtle.digest("SHA-256",d));return{digest:t.utils.bytesToHex(l),secret:o,salt:m,nonce:p,payload:d}}get contentType(){return m}encode(e){if(!e.url.startsWith("https"))throw new Error("scheme must be https");return{type:m,parameters:{contentDigest:e.contentDigest,salt:t.utils.bytesToHex(e.salt),nonce:t.utils.bytesToHex(e.nonce),secret:t.utils.bytesToHex(e.secret),scheme:e.scheme,contentLength:String(e.contentLength),filename:e.filename},content:(new TextEncoder).encode(e.url)}}decode(e){return{url:(new TextDecoder).decode(e.content),contentDigest:e.parameters.contentDigest,salt:t.utils.hexToBytes(e.parameters.salt),nonce:t.utils.hexToBytes(e.parameters.nonce),secret:t.utils.hexToBytes(e.parameters.secret),scheme:e.parameters.scheme,contentLength:parseInt(e.parameters.contentLength,10),filename:e.parameters.filename}}fallback(e){return`Can’t display "${e.filename}". This app doesn’t support attachments.`}shouldPush(){return!0}}export{c as AttachmentCodec,s as ContentTypeAttachment,m as ContentTypeRemoteAttachment,p as RemoteAttachmentCodec};
+import{ContentTypeId as e}from"@xmtp/content-type-primitives";import*as t from"@noble/secp256k1";import{content as n}from"@xmtp/proto";import{Ciphertext as r,decrypt as o,encrypt as a}from"@xmtp/xmtp-js";const s=new e({authorityId:"xmtp.org",typeId:"attachment",versionMajor:1,versionMinor:0});class c{get contentType(){return s}encode(e){return{type:s,parameters:{filename:e.filename,mimeType:e.mimeType},content:e.data}}decode(e){return{filename:e.parameters.filename,mimeType:e.parameters.mimeType,data:e.content}}fallback(e){return`Can’t display "${e.filename}". This app doesn’t support attachments.`}shouldPush(){return!0}}const i=self.crypto,m=new e({authorityId:"xmtp.org",typeId:"remoteStaticAttachment",versionMajor:1,versionMinor:0});class p{static async load(a,s){const c=await fetch(a.url),m=new Uint8Array(await c.arrayBuffer());if(!m)throw new Error(`no payload for remote attachment at ${a.url}`);const p=new Uint8Array(await i.subtle.digest("SHA-256",m));if(t.utils.bytesToHex(p)!==a.contentDigest)throw new Error("content digest does not match");const d=new r({aes256GcmHkdfSha256:{hkdfSalt:a.salt,gcmNonce:a.nonce,payload:m}}),l=await o(d,a.secret),h=n.EncodedContent.decode(l);if(!h||!h.type)throw new Error("no encoded content");const y=h.type;if(!y)throw new Error("no content type");const u=s.codecFor(new e(y));if(!u)throw new Error(`no codec found for ${h.type?.typeId}`);return u.decode(h,s)}static async encodeEncrypted(e,r){const o=i.getRandomValues(new Uint8Array(32)),s=n.EncodedContent.encode(r.encode(e,{codecFor(){}})).finish(),c=await a(s,o),m=c.aes256GcmHkdfSha256?.hkdfSalt,p=c.aes256GcmHkdfSha256?.gcmNonce,d=c.aes256GcmHkdfSha256?.payload;if(!m||!p||!d)throw new Error("missing encryption key");const l=new Uint8Array(await i.subtle.digest("SHA-256",d));return{digest:t.utils.bytesToHex(l),secret:o,salt:m,nonce:p,payload:d}}get contentType(){return m}encode(e){if(!e.url.startsWith("https"))throw new Error("scheme must be https");return{type:m,parameters:{contentDigest:e.contentDigest,salt:t.utils.bytesToHex(e.salt),nonce:t.utils.bytesToHex(e.nonce),secret:t.utils.bytesToHex(e.secret),scheme:e.scheme,contentLength:String(e.contentLength),filename:e.filename},content:(new TextEncoder).encode(e.url)}}decode(e){return{url:(new TextDecoder).decode(e.content),contentDigest:e.parameters.contentDigest,salt:t.utils.hexToBytes(e.parameters.salt),nonce:t.utils.hexToBytes(e.parameters.nonce),secret:t.utils.hexToBytes(e.parameters.secret),scheme:e.parameters.scheme,contentLength:parseInt(e.parameters.contentLength,10),filename:e.parameters.filename}}fallback(e){return`Can’t display "${e.filename}". This app doesn’t support attachments.`}shouldPush(){return!0}}export{c as AttachmentCodec,s as ContentTypeAttachment,m as ContentTypeRemoteAttachment,p as RemoteAttachmentCodec};
 //# sourceMappingURL=index.js.map
